/*
		 // Handle primitives

		 const parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 const values = [];

		 for ( const key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 const geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */

/*
		Calculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.

		p  : degree
		U  : knot vector
		P  : control points
		u  : Parametric points
		nd : number of derivatives

		returns array[d+1] with derivatives
		*/

/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */

/*
	Calculate "K over I"

	returns k!/(i!(k-i)!)
	*/

/*
	Calculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.

	p : degree of B-Spline
	U : knot vector
	P : control points (x, y, z, w)
	u : parametric point

	returns point for given u
	*/

/*
	Calculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.

	p  : degree
	U  : knot vector
	P  : control points in homogeneous space
	u  : parametric points
	nd : number of derivatives

	returns array with derivatives.
	*/

/*
	Calculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.

	span : span in which u lies
	u    : parametric point
	p    : degree
	n    : number of derivatives to calculate
	U    : knot vector

	returns array[n+1][p+1] with basis functions derivatives
	*/

/*
	Calculate basis functions. See The NURBS Book, page 70, algorithm A2.2

	span : span in which u lies
	u    : parametric point
	p    : degree
	U    : knot vector

	returns array[p+1] with basis functions values.
	*/

/*
	Calculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.

	Pders : result of function calcBSplineDerivatives

	returns array with derivatives for rational curve.
	*/

/*
	Calculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.

	p1, p2 : degrees of B-Spline surface
	U1, U2 : knot vectors
	P      : control points (x, y, z, w)
	u, v   : parametric values

	returns point for given (u, v)
	*/

/*
	Finds knot vector span.

	p : degree
	u : parametric value
	U : knot vector

	returns the span
	*/

/*
    position: { x: 0,  y: 0, z: 0 }, 
    scale: 200, 
    tex: _t.Assets.textures.particles[0], 
    emitters: 60, 
    maxParticles: 6000, 
    colors: !obj.colors ? false : obj.colors,
    parent: cluster.area
    */

/*
  Backward and forward arrow buttons
 */

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/

/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

/* 0 */

/* 1 */

/* 2 */

/* 3 */

/* 4 */

/* 5 */

/* 6 */

/* 7 */

/* DOM_DELTA_LINE */

/* Faces */

/* Vertices */

/* WEBPACK VAR INJECTION */

/* array of Vector(2|3|4) */

/* array of reals */

/* binding */

/* eslint-disable */

/* eslint-disable no-undef */

/* eslint-enable */

/* eslint-enable no-undef */

/* globals __webpack_amd_options__ */

/* glsl */

/* harmony default export */

/* harmony export (binding) */

/* harmony import */

/* index in knots */

/* unused harmony export ACESFilmicToneMapping */

/* unused harmony export AddOperation */

/* unused harmony export AdditiveAnimationBlendMode */

/* unused harmony export AlphaFormat */

/* unused harmony export AlwaysDepth */

/* unused harmony export AlwaysStencilFunc */

/* unused harmony export AmbientLightProbe */

/* unused harmony export AnimationLoader */

/* unused harmony export AnimationMixer */

/* unused harmony export AnimationObjectGroup */

/* unused harmony export AnimationUtils */

/* unused harmony export ArcCurve */

/* unused harmony export ArrayCamera */

/* unused harmony export ArrowHelper */

/* unused harmony export Audio */

/* unused harmony export AudioAnalyser */

/* unused harmony export AudioContext */

/* unused harmony export AudioListener */

/* unused harmony export AudioLoader */

/* unused harmony export AxesHelper */

/* unused harmony export AxisHelper */

/* unused harmony export BasicDepthPacking */

/* unused harmony export BasicShadowMap */

/* unused harmony export BinaryTextureLoader */

/* unused harmony export BooleanKeyframeTrack */

/* unused harmony export BoundingBoxHelper */

/* unused harmony export Box2 */

/* unused harmony export Box3Helper */

/* unused harmony export BoxBufferGeometry */

/* unused harmony export BoxGeometry */

/* unused harmony export BoxHelper */

/* unused harmony export BufferGeometryLoader */

/* unused harmony export ByteType */

/* unused harmony export Cache */

/* unused harmony export Camera */

/* unused harmony export CameraHelper */

/* unused harmony export CanvasRenderer */

/* unused harmony export CanvasTexture */

/* unused harmony export CatmullRomCurve3 */

/* unused harmony export CineonToneMapping */

/* unused harmony export CircleBufferGeometry */

/* unused harmony export CircleGeometry */

/* unused harmony export ColorKeyframeTrack */

/* unused harmony export CompressedTexture */

/* unused harmony export CompressedTextureLoader */

/* unused harmony export ConeBufferGeometry */

/* unused harmony export ConeGeometry */

/* unused harmony export CubeCamera */

/* unused harmony export CubeReflectionMapping */

/* unused harmony export CubeRefractionMapping */

/* unused harmony export CubeTexture */

/* unused harmony export CubeUVReflectionMapping */

/* unused harmony export CubeUVRefractionMapping */

/* unused harmony export CubicBezierCurve */

/* unused harmony export CubicBezierCurve3 */

/* unused harmony export CubicInterpolant */

/* unused harmony export CullFaceBack */

/* unused harmony export CullFaceFront */

/* unused harmony export CullFaceFrontBack */

/* unused harmony export CullFaceNone */

/* unused harmony export CurvePath */

/* unused harmony export CustomToneMapping */

/* unused harmony export CylinderBufferGeometry */

/* unused harmony export CylinderGeometry */

/* unused harmony export Cylindrical */

/* unused harmony export DataTexture2DArray */

/* unused harmony export DataTexture3D */

/* unused harmony export DataTextureLoader */

/* unused harmony export DataUtils */

/* unused harmony export DecrementStencilOp */

/* unused harmony export DecrementWrapStencilOp */

/* unused harmony export DefaultLoadingManager */

/* unused harmony export DepthFormat */

/* unused harmony export DepthStencilFormat */

/* unused harmony export DirectionalLightHelper */

/* unused harmony export DiscreteInterpolant */

/* unused harmony export DodecahedronBufferGeometry */

/* unused harmony export DodecahedronGeometry */

/* unused harmony export DynamicBufferAttribute */

/* unused harmony export DynamicCopyUsage */

/* unused harmony export DynamicReadUsage */

/* unused harmony export EdgesGeometry */

/* unused harmony export EdgesHelper */

/* unused harmony export EllipseCurve */

/* unused harmony export EqualDepth */

/* unused harmony export EqualStencilFunc */

/* unused harmony export EquirectangularRefractionMapping */

/* unused harmony export EventDispatcher */

/* unused harmony export ExtrudeBufferGeometry */

/* unused harmony export ExtrudeGeometry */

/* unused harmony export FaceColors */

/* unused harmony export FlatShading */

/* unused harmony export Float16BufferAttribute */

/* unused harmony export Float32Attribute */

/* unused harmony export Float64Attribute */

/* unused harmony export Float64BufferAttribute */

/* unused harmony export Fog */

/* unused harmony export Font */

/* unused harmony export FontLoader */

/* unused harmony export Frustum */

/* unused harmony export GLBufferAttribute */

/* unused harmony export GLSL1 */

/* unused harmony export GLSL3 */

/* unused harmony export GammaEncoding */

/* unused harmony export GreaterDepth */

/* unused harmony export GreaterEqualDepth */

/* unused harmony export GreaterEqualStencilFunc */

/* unused harmony export GreaterStencilFunc */

/* unused harmony export GridHelper */

/* unused harmony export HalfFloatType */

/* unused harmony export HemisphereLightHelper */

/* unused harmony export HemisphereLightProbe */

/* unused harmony export IcosahedronBufferGeometry */

/* unused harmony export ImageBitmapLoader */

/* unused harmony export ImageLoader */

/* unused harmony export ImageUtils */

/* unused harmony export ImmediateRenderObject */

/* unused harmony export IncrementStencilOp */

/* unused harmony export IncrementWrapStencilOp */

/* unused harmony export InstancedBufferAttribute */

/* unused harmony export InstancedBufferGeometry */

/* unused harmony export InstancedInterleavedBuffer */

/* unused harmony export Int16Attribute */

/* unused harmony export Int16BufferAttribute */

/* unused harmony export Int32Attribute */

/* unused harmony export Int32BufferAttribute */

/* unused harmony export Int8Attribute */

/* unused harmony export Int8BufferAttribute */

/* unused harmony export IntType */

/* unused harmony export InterleavedBuffer */

/* unused harmony export InterleavedBufferAttribute */

/* unused harmony export Interpolant */

/* unused harmony export InterpolateDiscrete */

/* unused harmony export InterpolateLinear */

/* unused harmony export InterpolateSmooth */

/* unused harmony export InvertStencilOp */

/* unused harmony export JSONLoader */

/* unused harmony export KeepStencilOp */

/* unused harmony export KeyframeTrack */

/* unused harmony export LOD */

/* unused harmony export LatheBufferGeometry */

/* unused harmony export LatheGeometry */

/* unused harmony export Layers */

/* unused harmony export LensFlare */

/* unused harmony export LessDepth */

/* unused harmony export LessEqualDepth */

/* unused harmony export LessEqualStencilFunc */

/* unused harmony export LessStencilFunc */

/* unused harmony export Light */

/* unused harmony export LightProbe */

/* unused harmony export Line3 */

/* unused harmony export LineCurve */

/* unused harmony export LineCurve3 */

/* unused harmony export LineDashedMaterial */

/* unused harmony export LineLoop */

/* unused harmony export LinePieces */

/* unused harmony export LineSegments */

/* unused harmony export LineStrip */

/* unused harmony export LinearEncoding */

/* unused harmony export LinearInterpolant */

/* unused harmony export LinearMipMapLinearFilter */

/* unused harmony export LinearMipMapNearestFilter */

/* unused harmony export LinearMipmapLinearFilter */

/* unused harmony export LinearMipmapNearestFilter */

/* unused harmony export LinearToneMapping */

/* unused harmony export LogLuvEncoding */

/* unused harmony export LoopOnce */

/* unused harmony export LoopPingPong */

/* unused harmony export LoopRepeat */

/* unused harmony export LuminanceAlphaFormat */

/* unused harmony export LuminanceFormat */

/* unused harmony export MOUSE */

/* unused harmony export Material */

/* unused harmony export MaterialLoader */

/* unused harmony export MaxEquation */

/* unused harmony export MeshDistanceMaterial */

/* unused harmony export MeshFaceMaterial */

/* unused harmony export MeshMatcapMaterial */

/* unused harmony export MeshPhysicalMaterial */

/* unused harmony export MeshToonMaterial */

/* unused harmony export MinEquation */

/* unused harmony export MultiMaterial */

/* unused harmony export MultiplyBlending */

/* unused harmony export MultiplyOperation */

/* unused harmony export NearestMipMapLinearFilter */

/* unused harmony export NearestMipMapNearestFilter */

/* unused harmony export NearestMipmapLinearFilter */

/* unused harmony export NearestMipmapNearestFilter */

/* unused harmony export NeverDepth */

/* unused harmony export NeverStencilFunc */

/* unused harmony export NoColors */

/* unused harmony export NoToneMapping */

/* unused harmony export NormalAnimationBlendMode */

/* unused harmony export NormalBlending */

/* unused harmony export NotEqualDepth */

/* unused harmony export NotEqualStencilFunc */

/* unused harmony export ObjectLoader */

/* unused harmony export ObjectSpaceNormalMap */

/* unused harmony export OctahedronBufferGeometry */

/* unused harmony export OctahedronGeometry */

/* unused harmony export OneFactor */

/* unused harmony export OneMinusDstAlphaFactor */

/* unused harmony export OneMinusDstColorFactor */

/* unused harmony export OneMinusSrcColorFactor */

/* unused harmony export PCFShadowMap */

/* unused harmony export PCFSoftShadowMap */

/* unused harmony export ParametricBufferGeometry */

/* unused harmony export ParametricGeometry */

/* unused harmony export Particle */

/* unused harmony export ParticleBasicMaterial */

/* unused harmony export ParticleSystem */

/* unused harmony export ParticleSystemMaterial */

/* unused harmony export Path */

/* unused harmony export Plane */

/* unused harmony export PlaneBufferGeometry */

/* unused harmony export PlaneHelper */

/* unused harmony export PointCloud */

/* unused harmony export PointCloudMaterial */

/* unused harmony export PointLightHelper */

/* unused harmony export PolarGridHelper */

/* unused harmony export PolyhedronBufferGeometry */

/* unused harmony export PolyhedronGeometry */

/* unused harmony export PositionalAudio */

/* unused harmony export PropertyMixer */

/* unused harmony export QuadraticBezierCurve */

/* unused harmony export QuadraticBezierCurve3 */

/* unused harmony export QuaternionLinearInterpolant */

/* unused harmony export REVISION */

/* unused harmony export RGBAIntegerFormat */

/* unused harmony export RGBA_ASTC_10x10_Format */

/* unused harmony export RGBA_ASTC_10x5_Format */

/* unused harmony export RGBA_ASTC_10x6_Format */

/* unused harmony export RGBA_ASTC_10x8_Format */

/* unused harmony export RGBA_ASTC_12x10_Format */

/* unused harmony export RGBA_ASTC_12x12_Format */

/* unused harmony export RGBA_ASTC_4x4_Format */

/* unused harmony export RGBA_ASTC_5x4_Format */

/* unused harmony export RGBA_ASTC_5x5_Format */

/* unused harmony export RGBA_ASTC_6x5_Format */

/* unused harmony export RGBA_ASTC_6x6_Format */

/* unused harmony export RGBA_ASTC_8x5_Format */

/* unused harmony export RGBA_ASTC_8x6_Format */

/* unused harmony export RGBA_ASTC_8x8_Format */

/* unused harmony export RGBA_BPTC_Format */

/* unused harmony export RGBA_ETC2_EAC_Format */

/* unused harmony export RGBA_PVRTC_2BPPV1_Format */

/* unused harmony export RGBA_PVRTC_4BPPV1_Format */

/* unused harmony export RGBA_S3TC_DXT1_Format */

/* unused harmony export RGBA_S3TC_DXT3_Format */

/* unused harmony export RGBA_S3TC_DXT5_Format */

/* unused harmony export RGBDEncoding */

/* unused harmony export RGBEEncoding */

/* unused harmony export RGBEFormat */

/* unused harmony export RGBIntegerFormat */

/* unused harmony export RGBM16Encoding */

/* unused harmony export RGBM7Encoding */

/* unused harmony export RGB_ETC1_Format */

/* unused harmony export RGB_ETC2_Format */

/* unused harmony export RGB_PVRTC_2BPPV1_Format */

/* unused harmony export RGB_PVRTC_4BPPV1_Format */

/* unused harmony export RGB_S3TC_DXT1_Format */

/* unused harmony export RGFormat */

/* unused harmony export RGIntegerFormat */

/* unused harmony export RawShaderMaterial */

/* unused harmony export Ray */

/* unused harmony export RectAreaLight */

/* unused harmony export RedFormat */

/* unused harmony export RedIntegerFormat */

/* unused harmony export ReplaceStencilOp */

/* unused harmony export ReverseSubtractEquation */

/* unused harmony export RingBufferGeometry */

/* unused harmony export RingGeometry */

/* unused harmony export SPE */

/* unused harmony export SRGB8_ALPHA8_ASTC_10x10_Format */

/* unused harmony export SRGB8_ALPHA8_ASTC_10x5_Format */

/* unused harmony export SRGB8_ALPHA8_ASTC_10x6_Format */

/* unused harmony export SRGB8_ALPHA8_ASTC_10x8_Format */

/* unused harmony export SRGB8_ALPHA8_ASTC_12x10_Format */

/* unused harmony export SRGB8_ALPHA8_ASTC_12x12_Format */

/* unused harmony export SRGB8_ALPHA8_ASTC_4x4_Format */

/* unused harmony export SRGB8_ALPHA8_ASTC_5x4_Format */

/* unused harmony export SRGB8_ALPHA8_ASTC_5x5_Format */

/* unused harmony export SRGB8_ALPHA8_ASTC_6x5_Format */

/* unused harmony export SRGB8_ALPHA8_ASTC_6x6_Format */

/* unused harmony export SRGB8_ALPHA8_ASTC_8x5_Format */

/* unused harmony export SRGB8_ALPHA8_ASTC_8x6_Format */

/* unused harmony export SRGB8_ALPHA8_ASTC_8x8_Format */

/* unused harmony export SceneUtils */

/* unused harmony export ShaderLib */

/* unused harmony export ShadowMaterial */

/* unused harmony export Shape */

/* unused harmony export ShapeBufferGeometry */

/* unused harmony export ShapeGeometry */

/* unused harmony export ShapePath */

/* unused harmony export ShapeUtils */

/* unused harmony export ShortType */

/* unused harmony export SkeletonHelper */

/* unused harmony export SmoothShading */

/* unused harmony export SphereBufferGeometry */

/* unused harmony export SphericalHarmonics3 */

/* unused harmony export SplineCurve */

/* unused harmony export SpotLightHelper */

/* unused harmony export Sprite */

/* unused harmony export SpriteMaterial */

/* unused harmony export SrcAlphaSaturateFactor */

/* unused harmony export SrcColorFactor */

/* unused harmony export StaticCopyUsage */

/* unused harmony export StaticReadUsage */

/* unused harmony export StereoCamera */

/* unused harmony export StreamCopyUsage */

/* unused harmony export StreamDrawUsage */

/* unused harmony export StreamReadUsage */

/* unused harmony export StringKeyframeTrack */

/* unused harmony export SubtractEquation */

/* unused harmony export SubtractiveBlending */

/* unused harmony export TOUCH */

/* unused harmony export TangentSpaceNormalMap */

/* unused harmony export TetrahedronBufferGeometry */

/* unused harmony export TetrahedronGeometry */

/* unused harmony export TextBufferGeometry */

/* unused harmony export TextGeometry */

/* unused harmony export TorusBufferGeometry */

/* unused harmony export TorusGeometry */

/* unused harmony export TorusKnotBufferGeometry */

/* unused harmony export TorusKnotGeometry */

/* unused harmony export TriangleFanDrawMode */

/* unused harmony export TriangleStripDrawMode */

/* unused harmony export TrianglesDrawMode */

/* unused harmony export TubeBufferGeometry */

/* unused harmony export TubeGeometry */

/* unused harmony export UVMapping */

/* unused harmony export Uint16Attribute */

/* unused harmony export Uint32Attribute */

/* unused harmony export Uint32BufferAttribute */

/* unused harmony export Uint8Attribute */

/* unused harmony export Uint8BufferAttribute */

/* unused harmony export Uint8ClampedAttribute */

/* unused harmony export Uint8ClampedBufferAttribute */

/* unused harmony export Uniform */

/* unused harmony export UniformsLib */

/* unused harmony export UnsignedByteType */

/* unused harmony export UnsignedInt248Type */

/* unused harmony export UnsignedIntType */

/* unused harmony export UnsignedShort4444Type */

/* unused harmony export UnsignedShort5551Type */

/* unused harmony export UnsignedShort565Type */

/* unused harmony export VSMShadowMap */

/* unused harmony export Vertex */

/* unused harmony export VertexColors */

/* unused harmony export VideoTexture */

/* unused harmony export WebGL1Renderer */

/* unused harmony export WebGLCubeRenderTarget */

/* unused harmony export WebGLMultisampleRenderTarget */

/* unused harmony export WebGLRenderTargetCube */

/* unused harmony export WebGLUtils */

/* unused harmony export WireframeGeometry */

/* unused harmony export WireframeHelper */

/* unused harmony export WrapAroundEnding */

/* unused harmony export XHRLoader */

/* unused harmony export ZeroCurvatureEnding */

/* unused harmony export ZeroSlopeEnding */

/* unused harmony export ZeroStencilOp */

/*!
  * PhotoSwipe 5.3.4 - https://photoswipe.com
  * (c) 2022 Dmytro Semenov
  */

/*!
  * PhotoSwipe Lightbox 5.3.4 - https://photoswipe.com
  * (c) 2022 Dmytro Semenov
  */

/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */

/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
*/

/*#__PURE__*/

/*&& isLeftToRight*/

/*&& isRightToLeft*/

/**
			* @PSEUDO_GATHER4
			* This texcoord has been offset by (-0.25, -0.125) in the vertex shader to
			* sample between edge, thus fetching four edges in a row.
			* Sampling with different offsets in each direction allows to disambiguate
			* which edges are active from the four fetched ones.
			*/

/**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */

/**
	 * Assumes 2 cameras that are parallel and share an X-axis, and that
	 * the cameras' projection and world matrices have already been set.
	 * And that near and far planes are identical for both cameras.
	 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
	 */

/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */

/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */

/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */

/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */

/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */

/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */

/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */

/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */

/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */

/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */

/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */

/**
         * @category Properties
         */

/**
         * An array of Meshes to collide with camera.
         * Be aware colliderMeshes may decrease performance. The collision test uses 4 raycasters from the camera since the near plane has 4 corners.
         * @category Properties
         */

/**
         * Controls how soon the `rest` event fires as the camera slows.
         * @category Properties
         */

/**
         * Force cancel user dragging.
         * @category Methods
         */

/**
         * Friction ratio of the boundary.
         * @category Properties
         */

/**
         * Maximum camera zoom.
         * @category Properties
         */

/**
         * Maximum distance for dolly. The value must be higher than `minDistance`.
         * PerspectiveCamera only.
         * @category Properties
         */

/**
         * Maximum horizontal angle in radians.
         * The angle has to be greater than `.minAzimuthAngle`.
         * The default value is `Infinity`.
         *
         * e.g.
         * ```
         * cameraControls.maxAzimuthAngle = Infinity;
         * ```
         * @category Properties
         */

/**
         * Maximum vertical angle in radians.
         * The angle has to be between `.maxPolarAngle` and `Math.PI` inclusive.
         * The default value is `Math.PI`.
         *
         * e.g.
         * ```
         * cameraControls.maxPolarAngle = Math.PI;
         * ```
         * @category Properties
         */

/**
         * Minimum camera zoom.
         * @category Properties
         */

/**
         * Minimum distance for dolly. The value must be higher than `0`.
         * PerspectiveCamera only.
         * @category Properties
         */

/**
         * Minimum horizontal angle in radians.
         * The angle has to be less than `.maxAzimuthAngle`.
         * The default value is `- Infinity`.
         *
         * e.g.
         * ```
         * cameraControls.minAzimuthAngle = - Infinity;
         * ```
         * @category Properties
         */

/**
         * Minimum vertical angle in radians.
         * The angle has to be between `0` and `.maxPolarAngle` inclusive.
         * The default value is `0`.
         *
         * e.g.
         * ```
         * cameraControls.maxPolarAngle = 0;
         * ```
         * @category Properties
         */

/**
         * Speed of azimuth (horizontal) rotation.
         * @category Properties
         */

/**
         * Speed of drag for truck and pedestal.
         * @category Properties
         */

/**
         * Speed of mouse-wheel dollying.
         * @category Properties
         */

/**
         * Speed of polar (vertical) rotation.
         * @category Properties
         */

/**
         * The damping inertia while dragging.
         * The value must be between `Math.EPSILON` to `1` inclusive.
         * Setting `1` to disable smooth transitions.
         * @category Properties
         */

/**
         * The damping inertia.
         * The value must be between `Math.EPSILON` to `1` inclusive.
         * Setting `1` to disable smooth transitions.
         * @category Properties
         */

/**
         * The same as `.screenSpacePanning` in three.js's OrbitControls.
         * @category Properties
         */

/**
         * `true` to enable Dolly-in to the mouse cursor coords.
         * @category Properties
         */

/**
         * `true` to enable Infinity Dolly.
         * When the Dolly distance is less than the `minDistance`, radius of the sphere will be set `minDistance` automatically.
         * @category Properties
         */

/**
       * Pass data to PhotoSwipe and open init
       *
       * @type {PhotoSwipe}
       */

/**
     * @deprecated `pan()` has been renamed to `truck()`
     * @category Methods
     */

/**
     * @param {Actions} actionName
     * @param {Point} point
     * @param {PointerEvent} originalEvent
     */

/**
     * @param {AnimationProps} props
     * @param {boolean=} isSpring
     */

/**
     * @param {AnimationProps} props
     */

/**
     * @param {Animation} animation
     */

/**
     * @param {Content} content
     */

/**
     * @param {HTMLElement} target
     * @param {'transform' | 'opacity'} prop
     * @param {string} propValue
     */

/**
     * @param {KeyboardEvent} e
     */

/**
     * @param {MouseEvent} e
     */

/**
     * @param {PhotoSwipeOptions} options
     * @private
     */

/**
     * @param {PointerEvent} e
     */

/**
     * @param {Point} point
     * @param {PointerEvent} originalEvent
     */

/**
     * @param {SlideData} slideData
     * @param {number} index
     */

/**
     * @param {Slide} slide
     */

/**
     * @param {UIElementData} elementData
     */

/**
     * @param {boolean=} animate
     */

/**
     * @param {number} index
     */

/**
     * @param {number} opacity
     */

/**
     * @param {number} width
     * @param {number} height
     */

/**
     * @param {number} x
     * @param {number} y
     */

/**
     * @param {{ x?: number, y?: number }} [centerPoint]
     */

/**
     * @private
     * @param {'x' | 'y'} axis
     * @param {number} currZoomLevel
     */

/**
     * @private
     * @param {'x' | 'y'} axis
     */

/**
     * @private
     * @param {PointerEvent} e
     */

/**
     * @private
     * @param {Type<PhotoSwipe> | { default: Type<PhotoSwipe> }} module
     * @param {number} uid
     */

/**
     * @private
     */

/**
     * @returns true if the tween is still playing after the update, false
     * otherwise (calling update on a paused tween still returns true because
     * it is still playing, just paused).
     */

/**
     * @returns {Boolean} If the content is currently loading
     */

/**
     * @returns {boolean} If content should use a placeholder (from msrc by default)
     */

/**
     * @returns {boolean} If placeholder should be kept after content is loaded
     */

/**
     * @returns {boolean} If the content can be zoomed
     */

/**
     * @returns {boolean} If the content is image
     */

/**
     * @see slide/slide.js toggleZoom
     */

/**
     * @see slide/slide.js zoomTo
     *
     * @param {Parameters<Slide['zoomTo']>} args
     */

/**
     * @template {keyof PhotoSwipeEventsMap} T
     * @param {T} name
     * @param {EventCallback<T>} fn
     */

/**
     * @template {keyof PhotoSwipeEventsMap} T
     * @param {T} name
     * @param {PhotoSwipeEventsMap[T]} [details]
     * @returns {AugmentedEvent<T>}
     */

/**
     * @template {keyof PhotoSwipeFiltersMap} T
     * @param {T} name
     * @param {Parameters<PhotoSwipeFiltersMap[T]>} args
     * @returns {Parameters<PhotoSwipeFiltersMap[T]>[0]}
     */

/**
     * @template {keyof PhotoSwipeFiltersMap} T
     * @param {T} name
     * @param {PhotoSwipeFiltersMap[T]} fn
     */

/**
     * @type {PoolItem[]}
     * @private
     */

/**
     * @type {{ [T in keyof PhotoSwipeEventsMap]?: ((event: AugmentedEvent<T>) => void)[] }}
     */

/**
     * @type {{ [T in keyof PhotoSwipeFiltersMap]?: Filter<T>[] }}
     */

/**
     * @type {{ x?: number; y?: number }}
     * @private
     */

/**
     * Activate the slide,
     * active slide is generally the current one,
     * meaning the user can see it.
     */

/**
     * Adds or removes event
     *
     * @param {HTMLElement | Window | Document} target
     * @param {string} type
     * @param {(e: any) => void} listener
     * @param {boolean} passive
     * @param {boolean=} unbind Whether the event should be added or removed
     * @param {boolean=} skipPool Whether events pool should be skipped
     */

/**
     * Adds the specified event listener.
     * @param type event name
     * @param listener handler function
     * @category Methods
     */

/**
     * Adds the specified event listener.
     * Applicable event types (which is `K`) are:
     * | Event name          | Timing |
     * | ------------------- | ------ |
     * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. ¹ |
     * | `'control'`         | When the user controls the camera (dragging). |
     * | `'controlend'`      | When the user ends to control the camera. ¹ |
     * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
     * | `'update'`          | When the camera position is updated. |
     * | `'wake'`            | When the camera starts moving. |
     * | `'rest'`            | When the camera movement is below `.restThreshold` ². |
     * | `'sleep'`           | When the camera end moving. |
     *
     * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
     * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
     *
     * e.g.
     * ```
     * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
     * ```
     * @param type event name
     * @param listener handler function
     * @category Methods
     */

/**
     * Append "heavy" DOM elements
     *
     * This may depend on a type of slide,
     * but generally these are large images.
     */

/**
     * Append the content
     */

/**
     * Append the image content to slide container
     */

/**
     * Appends slide content to DOM
     *
     * @param {HTMLElement} holderElement
     */

/**
     * Apply pan and keep it within bounds.
     *
     * @param {number} panX
     * @param {number} panY
     */

/**
     * Apply size to current slide content,
     * based on the current resolution and scale.
     *
     * @param {boolean=} force if size should be updated even if dimensions weren't changed
     */

/**
     * Apply transform and scale based on
     * the current pan position (this.pan) and zoom level (this.currZoomLevel)
     */

/**
     * Assign slide to content
     *
     * @param {Slide} slide
     */

/**
     * Attach all internal event handlers to enable drag control.
     * @category Methods
     */

/**
     * Boolean type.
             * @type {String}
     */

/**
     * Calculate the distance to fit the box.
     * @param width box width
     * @param height box height
     * @param depth box depth
     * @returns distance
     * @category Methods
     */

/**
     * Calculate the distance to fit the sphere.
     * @param radius sphere radius
     * @returns distance
     * @category Methods
     */

/**
     * Change the slide
     * @param {number} index New index
     */

/**
     * Close the gallery.
     * After closing transition ends - destroy it
     */

/**
     * Content load error handler
     */

/**
     * Content load success handler
     */

/**
     * Converts DOM element to item data object.
     *
     * @param {HTMLElement} element DOM element
     */

/**
     * Converts touch, pointer or mouse event
     * to PhotoSwipe point.
     *
     * @private
     * @param {Touch | PointerEvent} e
     * @param {Point} p
     */

/**
     * Correct currZoomLevel and pan if they are
     * beyond minimum or maximum values.
     * With animation.
     *
     * @param {boolean=} ignoreGesture
     * Wether gesture coordinates should be ignored when calculating destination pan position.
     */

/**
     * Correct pan position if it's beyond the bounds
     *
     * @param {Axis} axis x or y
     * @param {number} panOffset
     */

/**
     * Create and append array of three items
     * that hold data about slides in DOM
     */

/**
     * Create main HTML structure of PhotoSwipe,
     * and add it to DOM
     *
     * @private
     */

/**
     * Creates a `CameraControls` instance.
     *
     * Note:
     * You **must install** three.js before using camera-controls. see [#install](#install)
     * Not doing so will lead to runtime errors (`undefined` references to THREE).
     *
     * e.g.
     * ```
     * CameraControls.install( { THREE } );
     * const cameraControls = new CameraControls( camera, domElement );
     * ```
     *
     * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
     * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
     * @category Constructor
     */

/**
     * Deactivate the content
     */

/**
     * Destroy the content
     */

/**
     * Destroys the gallery:
     * - instantly closes the gallery
     * - unbinds events,
     * - cleans intervals and timeouts
     * - removes elements from DOM
     */

/**
     * Detach all internal event handlers to disable drag control.
     */

/**
     * Display error message
     */

/**
     * Dispose the cameraControls instance itself, remove all eventListeners.
     * @category Methods
     */

/**
     * Dolly in/out camera position to given distance.
     * @param distance Distance of dolly.
     * @param enableTransition Whether to move smoothly or immediately.
     * @category Methods
     */

/**
     * Dolly in/out camera position.
     * @param distance Distance of dollyIn. Negative number for dollyOut.
     * @param enableTransition Whether to move smoothly or immediately.
     * @category Methods
     */

/**
     * Fire an event type.
     * @param event DispatcherEvent
     * @category Methods
     */

/**
     * Fired each time zoom or pan position is changed.
     * Update classes that control visibility of zoom button and cursor icon.
     */

/**
     * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
     * set `cover: true` to fill enter screen.
     * e.g.
     * ```
     * cameraControls.fitToBox( myMesh );
     * ```
     * @param box3OrObject Axis aligned bounding box to fit the view.
     * @param enableTransition Whether to move smoothly or immediately.
     * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
     * @returns Transition end promise
     * @category Methods
     */

/**
     * Fit the viewport to the sphere or the bounding sphere of the object.
     * @param sphereOrMesh
     * @param enableTransition
     * @category Methods
     */

/**
     * Get all state in JSON string
     * @category Methods
     */

/**
     * Get array of gallery DOM elements,
     * based on childSelector and gallery element.
     *
     * @param {HTMLElement} galleryElement
     */

/**
     * Get index of gallery item that was clicked.
     *
     * @param {MouseEvent} e click event
     */

/**
     * Get initial image zoom level.
     *
     * @private
     * @return {number}
     */

/**
     * Get item data by index.
     *
     * "item data" should contain normalized information that PhotoSwipe needs to generate a slide.
     * For example, it may contain properties like
     * `src`, `srcset`, `w`, `h`, which will be used to generate a slide with image.
     *
     * @param {number} index
     */

/**
     * Get its client rect and package into given `DOMRect` .
     */

/**
     * Get looped slide index
     * (for example, -1 will return the last slide)
     *
     * @param {number} index
     */

/**
     * Get pan position after zoom at a given `point`.
     *
     * Always call setZoomLevel(newZoomLevel) beforehand to recalculate
     * pan bounds according to the new zoom level.
     *
     * @param {'x' | 'y'} axis
     * @param {{ x?: number; y?: number }} [point]
     * point based on which zoom is performed, usually refers to the current mouse position,
     * if false - viewport center will be used.
     * @param {number=} prevZoomLevel Zoom level before new zoom was applied.
     */

/**
     * Get position and dimensions of small thumbnail
     *   {x:,y:,w:}
     *
     * Height is optional (calculated based on the large image)
     */

/**
     * Get total number of slides
     *
     * @returns {number}
     */

/**
     * Get velocity for axis
     *
     * @private
     * @param {'x' | 'y'} axis
     * @param {number} duration
     */

/**
     * Get zoom level to which image will be zoomed after double-tap gesture,
     * or when user clicks on zoom icon,
     * or mouse-click on image itself.
     * If you return 1 image will be zoomed to its original size.
     *
     * @private
     * @return {number}
     */

/**
     * Getter for the current `ACTION`.
     * readonly value.
     * @category Properties
     */

/**
     * Go to the next slide.
     */

/**
     * Go to the previous slide.
     */

/**
     * If the PhotoSwipe can have continious loop
     * @returns Boolean
     */

/**
     * If the slide can be zoomed
     */

/**
     * If the slide in the current state can be panned by the user
     */

/**
     * Injects THREE as the dependency. You can then proceed to use CameraControls.
     *
     * e.g
     * ```javascript
     * CameraControls.install( { THREE: THREE } );
     * ```
     *
     * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
     *
     * ```js
     * import {
     * 	Vector2,
     * 	Vector3,
     * 	Vector4,
     * 	Quaternion,
     * 	Matrix4,
     * 	Spherical,
     * 	Box3,
     * 	Sphere,
     * 	Raycaster,
     * 	MathUtils,
     * } from 'three';
     *
     * const subsetOfTHREE = {
     * 	Vector2   : Vector2,
     * 	Vector3   : Vector3,
     * 	Vector4   : Vector4,
     * 	Quaternion: Quaternion,
     * 	Matrix4   : Matrix4,
     * 	Spherical : Spherical,
     * 	Box3      : Box3,
     * 	Sphere    : Sphere,
     * 	Raycaster : Raycaster,
     * 	MathUtils : {
     * 		DEG2RAD: MathUtils.DEG2RAD,
     * 		clamp: MathUtils.clamp,
     * 	},
     * };

     * CameraControls.install( { THREE: subsetOfTHREE } );
     * ```
     * @category Statics
     */

/**
     * Lazy-load by slide data
     *
     * @param {SlideData} itemData Data about the slide
     * @param {number} index
     * @returns Image that is being decoded or false.
     */

/**
     * Load and open PhotoSwipe
     *
     * @param {number} index
     * @param {DataSource=} dataSource
     * @param {{ x?: number; y?: number }} [initialPoint]
     */

/**
     * Load the main module and the slide content by index
     *
     * @param {number} index
     * @param {DataSource=} dataSource
     */

/**
     * Make an orbit with given points.
     * @param positionX
     * @param positionY
     * @param positionZ
     * @param targetX
     * @param targetY
     * @param targetZ
     * @param enableTransition
     * @category Methods
     */

/**
     * Maximum zoom level when user zooms
     * via zoom/pinch gesture,
     * via cmd/ctrl-wheel or via trackpad.
     *
     * @private
     * @return {number}
     */

/**
     * Move forward / backward.
     * @param distance Amount to move forward / backward. Negative value to move backward
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */

/**
     * Move main scroll by X amount of slides.
     * For example:
     *   `-1` will move to the previous slide,
     *    `0` will reset the scroll position of the current slide,
     *    `3` will move three slides forward
     *
     * If loop option is enabled - index will be automatically looped too,
     * (for example `-1` will move to the last slide of the gallery).
     *
     * @param {number} diff
     * @param {boolean=} animate
     * @param {number=} velocityX
     * @returns {boolean} whether index was changed or not
     */

/**
     * Move target position to given point.
     * @param x x coord to move center position
     * @param y y coord to move center position
     * @param z z coord to move center position
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */

/**
     * Move the X position of the main scroll container
     *
     * @param {number} x
     * @param {boolean=} dragging
     */

/**
     * Normalize camera azimuth angle rotation between 0 and 360 degrees.
     * @category Methods
     */

/**
     * Number type.
     * @type {String}
             */

/**
     * Object type.
     * @type {String}
     */

/**
     * Page resize event handler
     *
     * @private
     */

/**
     * Page scroll offset is used
     * to get correct coordinates
     * relative to PhotoSwipe viewport.
     *
     * @private
     */

/**
     * Parses and normalizes points from the touch, mouse or pointer event.
     * Updates p1 and p2.
     *
     * @private
     * @param {PointerEvent | TouchEvent} e
     * @param {'up' | 'down' | 'move'} pointerType Normalized pointer type
     */

/**
     * Parses user-defined zoom option.
     *
     * @private
     * @param {'initial' | 'secondary' | 'max'} optionPrefix Zoom level option prefix (initial, secondary, max)
     */

/**
     * Preload content
     *
     * @param {boolean=} isLazy
     * @param {boolean=} reload
     */

/**
     * Preload content with lazy-loading param
     */

/**
     * Preload image
     *
     * @param {boolean} isLazy
     */

/**
     * Presence of the specified event listener.
     * @param type event name
     * @param listener handler function
     * @category Methods
     */

/**
     * Refresh/reload content of a slide by its index
     *
     * @param {number} slideIndex
     */

/**
     * Relation between pan Y position and third of viewport height.
     *
     * When we are at initial position (center bounds) - the ratio is 0,
     * if position is shifted upwards - the ratio is negative,
     * if position is shifted downwards - the ratio is positive.
     *
     * @private
     * @param {number} panY The current pan Y position.
     */

/**
     * Remove the content from DOM
     */

/**
     * Removes all bound events
     */

/**
     * Removes all event listeners
     * @param type event name
     * @category Methods
     */

/**
     * Removes an image from cache, does not destroy() it, just removes.
     *
     * @param {number} index
     */

/**
     * Removes event listeners
     *
     * @param {HTMLElement | Window | Document} target
     * @param {string} type
     * @param {(e: any) => void} listener
     * @param {boolean=} passive
     */

/**
     * Removes the specified event listener
     * @param type event name
     * @param listener handler function
     * @category Methods
     */

/**
     * Removes the specified event listener
     * e.g.
     * ```
     * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
     * ```
     * @param type event name
     * @param listener handler function
     * @category Methods
     */

/**
     * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
     * @param json
     * @param enableTransition
     * @category Methods
     */

/**
     * Reset X position of the main scroller to zero
     */

/**
     * Reset all rotation and position to defaults.
     * @param enableTransition
     * @category Methods
     */

/**
     * Returns `true` if the controls are active updating.
     * readonly value.
     * @category Properties
     */

/**
     * Returns its current focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
     * @param out current focal offset
     * @category Methods
     */

/**
     * Returns its current gazing target, which is the center position of the orbit.
     * @param out current gazing target
     * @category Methods
     */

/**
     * Returns its current position.
     * @param out current position
     * @category Methods
     */

/**
     * Returns true if any pan or zoom transition is running
     */

/**
     * Returns true if main scroll transition is running
     */

/**
     * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
     * Camera view will rotate over the orbit pivot absolutely:
     *
     * azimuthAngle
     * ```
     *       0º
     *         \
     * 90º -----+----- -90º
     *           \
     *           180º
     * ```
     * | direction | angle                  |
     * | --------- | ---------------------- |
     * | front     | 0º                     |
     * | left      | 90º (`Math.PI / 2`)    |
     * | right     | -90º (`- Math.PI / 2`) |
     * | back      | 180º (`Math.PI`)       |
     *
     * polarAngle
     * ```
     *     180º
     *      |
     *      90º
     *      |
     *      0º
     * ```
     * | direction            | angle                  |
     * | -------------------- | ---------------------- |
     * | top/sky              | 180º (`Math.PI`)       |
     * | horizontal from view | 90º (`Math.PI / 2`)    |
     * | bottom/floor         | 0º                     |
     *
     * @param azimuthAngle Azimuth rotate angle to. In radian.
     * @param polarAngle Polar rotate angle to. In radian.
     * @param enableTransition  Whether to move smoothly or immediately
     * @category Methods
     */

/**
     * Rotate azimuthal angle(horizontal) and polar angle(vertical).
     * Every value is added to the current value.
     * @param azimuthAngle Azimuth rotate angle. In radian.
     * @param polarAngle Polar rotate angle. In radian.
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */

/**
     * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
     *
     * e.g.
     * ```
     * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
     * ```
     * @param azimuthAngle Azimuth rotate angle. In radian.
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */

/**
     * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
     *
     * e.g.
     * ```
     * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
     * ```
     * @param polarAngle Polar rotate angle. In radian.
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */

/**
     * Set (or unset) the current viewport.
     * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
     * @param viewportOrX
     * @param y
     * @param width
     * @param height
     * @category Methods
     */

/**
     * Set current camera position as the default position.
     * @category Methods
     */

/**
     * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
     * @param x
     * @param y
     * @param z
     * @param enableTransition
     * @category Methods
     */

/**
     * Set orbit point without moving the camera.
     * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
     * @param targetX
     * @param targetY
     * @param targetZ
     * @category Methods
     */

/**
     * Set pan position of the current slide.
     * Apply friction if the position is beyond the pan bounds,
     * or if custom friction is defined.
     *
     * @private
     * @param {'x' | 'y'} axis
     * @param {number} potentialPan
     * @param {number=} customFriction (0.1 - 1)
     */

/**
     * Set resolution and re-render the image.
     *
     * For example, if the real image size is 2000x1500,
     * and resolution is 0.5 - it will be rendered as 1000x750.
     *
     * Image with zoom level 2 and resolution 0.5 is
     * the same as image with zoom level 1 and resolution 1.
     *
     * Used to optimize animations and make
     * sure that browser renders image in highest quality.
     * Also used by responsive images to load the correct one.
     *
     * @param {number} newResolution
     */

/**
     * Set slide content
     *
     * @param {ItemHolder} holder mainScroll.itemHolders array item
     * @param {number} index Slide index
     * @param {boolean=} force If content should be set even if index wasn't changed
     */

/**
     * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
     * @param box3
     * @category Methods
     */

/**
     * Set translate and scale based on current resolution
     *
     * @param {number} x
     * @param {number} y
     * @param {number} zoom
     */

/**
     * Similar to setLookAt, but it interpolates between two states.
     * @param positionAX
     * @param positionAY
     * @param positionAZ
     * @param targetAX
     * @param targetAY
     * @param targetAZ
     * @param positionBX
     * @param positionBY
     * @param positionBZ
     * @param targetBX
     * @param targetBY
     * @param targetBZ
     * @param t
     * @param enableTransition
     * @category Methods
     */

/**
     * Size of scrollable PhotoSwipe viewport
     *
     * @type {{ x?: number; y?: number }}
     */

/**
     * Stop all pan or zoom transitions
     */

/**
     * String type.
       * @type {String}
     */

/**
     * Sync camera-up direction.
     * When camera-up vector is changed, `.updateCameraUp()` must be called.
     * @category Methods
     */

/**
     * The camera to be controlled
     * @category Properties
     */

/**
     * The slide should destroy itself, it will never be used again.
     * (unbind all events and destroy internal components)
     */

/**
     * Trap focus inside photoswipe
     *
     * @param {FocusEvent} e
     */

/**
     * Triggered when this slide becomes inactive.
     *
     * Slide can become inactive only after it was active.
     */

/**
     * Triggered when this slide is active (selected).
     *
     * If it's part of opening/closing transition -
     * activate() will trigger after the transition is ended.
     */

/**
     * Truck and pedestal camera using current azimuthal angle
     * @param x Horizontal translate amount
     * @param y Vertical translate amount
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */

/**
     * Unbinds all events, closes PhotoSwipe if it's open.
     */

/**
     * Update camera position and directions.
     * This should be called in your tick loop every time, and returns true if re-rendering is needed.
     * @param delta
     * @returns updated
     * @category Methods
     */

/**
     * Update content size
     *
     * @param {Number} width
     * @param {Number} height
     */

/**
     * Update image srcset sizes attribute based on width and height
     */

/**
     * Update position of the main scroll,
     * or/and update pan position of the current slide.
     *
     * Should return true if it changes (or can change) main scroll.
     *
     * @private
     * @param {'x' | 'y'} axis
     */

/**
     * Update size of all elements.
     * Executed on init and on page resize.
     *
     * @param {boolean=} force Update size even if size of viewport was not changed.
     */

/**
     * Update slides X positions and set their content
     */

/**
     * Update velocity at 50ms interval
     *
     * @param {boolean=} force
     */

/**
     * Updates zoom level property and recalculates new pan bounds,
     * unlike zoomTo it does not apply transform (use applyCurrentZoomPan)
     *
     * @param {number} currZoomLevel
     */

/**
     * Values will be distributed along a line.
     * @type {Number}
     */

/**
     * Values will be distributed on a 2d-disc shape.
     * @type {Number}
     */

/**
     * Values will be distributed on a sphere.
     * @type {Number}
     */

/**
     * Values will be distributed within a box.
     * @type {Number}
     */

/**
     * Whether camera position should be enclosed in the boundary or not.
     * @category Properties
     */

/**
     * Whether mouse is detected
     */

/**
     * Whether or not the controls are enabled.
     * `false` to disable user dragging/touch-move, but all methods works.
     * @category Properties
     */

/**
     * Whether scroll position is shifted.
     * For example, it will return true if the scroll is being dragged or animated.
     */

/**
     * Whether the main scroll can be horizontally swiped to the next or previous slide.
     */

/**
     * X position of the main scroll for the current slide
     * (ignores position during dragging)
     */

/**
     * Zoom current slide image to...
     *
     * @param {number} destZoomLevel Destination zoom level.
     * @param {{ x?: number; y?: number }} centerPoint
     * Transform origin center point, or false if viewport center should be used.
     * @param {number | false} [transitionDuration] Transition duration, may be set to 0.
     * @param {boolean=} ignoreBounds Minimum and maximum zoom levels will be ignored.
     * @return {boolean=} Returns true if animated.
     */

/**
     * Zoom in/out camera to given scale. The value overwrites camera zoom.
     * Limits set with .minZoom and .maxZoom
     * @param zoom
     * @param enableTransition
     * @category Methods
     */

/**
     * Zoom in/out camera. The value is added to camera zoom.
     * Limits set with `.minZoom` and `.maxZoom`
     * @param zoomStep zoom scale
     * @param enableTransition Whether to move smoothly or immediately
     * @category Methods
     */

/**
     * _calculateItemBoundsForAxis
     *
     * @param {Axis} axis
     */

/**
     * background (backdrop) opacity
     *
     * @type {number}
     */

/**
     * get/set Current distance.
     * @category Properties
     */

/**
     * get/set the azimuth angle (horizontal) in radians.
     * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
     * @category Properties
     */

/**
     * get/set the polar angle (vertical) in radians.
     * @category Properties
     */

/**
     * list all ACTIONs
     * @category Statics
     */

/**
     * offset of viewport relative to document
     *
     * @type {{ x?: number; y?: number }}
     */

/**
     * setLookAt without position, Stay still at the position.
     * @param targetX
     * @param targetY
     * @param targetZ
     * @param enableTransition
     * @category Methods
     */

/**
     * setLookAt without target, keep gazing at the current target
     * @param positionX
     * @param positionY
     * @param positionZ
     * @param enableTransition
     * @category Methods
     */

/**
   *
   * @param {'mouse' | 'touch' | 'pointer'} pref
   * @param {'down' | 'start'} down
   * @param {'up' | 'end'} up
   * @param {'cancel'} [cancel]
   */

/**
   * @param {AnimationProps} props
   */

/**
   * @param {Gestures} gestures
   */

/**
   * @param {PhotoSwipeOptions} options
   */

/**
   * @param {PhotoSwipeOptions} options PhotoSwipe options
   * @param {SlideData} itemData Slide data
   * @param {number} index Slide index
   * @param {PhotoSwipe=} pswp PhotoSwipe instance, can be undefined if not initialized yet
   */

/**
   * @param {PhotoSwipe} pswp
   */

/**
   * @param {Point} point
   * @param {PointerEvent} originalEvent
   */

/**
   * @param {SlideData} data
   * @param {number} index
   * @param {PhotoSwipe} pswp
   */

/**
   * @param {SlideData} itemData Slide data
   * @param {PhotoSwipe} instance PhotoSwipe or PhotoSwipeLightbox instance
   * @param {number} index
   */

/**
   * @param {Slide} slide
   */

/**
   * @param {T} type
   * @param {PhotoSwipeEventsMap[T]} [details]
   */

/**
   * @param {number} deltaPosition Difference between current and end position of the animation
   * @param {number} deltaTime Frame duration in milliseconds
   *
   * @returns {number} Displacement, relative to the end position.
   */

/**
   * @param {number} initialVelocity Initial velocity, px per ms.
   *
   * @param {number} dampingRatio
   * Determines how bouncy animation will be.
   * From 0 to 1, 0 - always overshoot, 1 - do not overshoot.
   * "overshoot" refers to part of animation that
   * goes beyond the final value.
   *
   * @param {number} naturalFrequency
   * Determines how fast animation will slow down.
   * The higher value - the stiffer the transition will be,
   * and the faster it will slow down.
   * Recommended value from 10 to 50
   */

/**
   * @param {number} width
   * @param {number} height
   */

/**
   * @param {string | false} imageSrc
   * @param {HTMLElement} container
   */

/**
   * @private
   * @param {TransitionEvent} e
   */

/**
   * @private
   * @param {WheelEvent} e
   */

/**
   * @template {keyof PhotoSwipeFiltersMap} T
   * @param {T} name
   * @param {PhotoSwipeFiltersMap[T]} fn
   * @param {number} priority
   */

/**
   * A map of supported distribution types used
   * by SPE.Emitter instances.
   *
   * These distribution types can be applied to
   * an emitter globally, which will affect the
   * `position`, `velocity`, and `acceleration`
   * value calculations for an emitter, or they
   * can be applied on a per-property basis.
   *
   * @enum {Number}
   */

/**
   * A map of types used by `SPE.utils.ensureTypedArg` and
   * `SPE.utils.ensureArrayTypedArg` to compare types against.
   *
   * @enum {String}
   */

/**
   * Adds event listeners
   *
   * @param {HTMLElement | Window | Document} target
   * @param {string} type Can be multiple, separated by space.
   * @param {(e: any) => void} listener
   * @param {boolean=} passive
   */

/**
   * Calculate initial, secondary and maximum zoom level for the specified slide.
   *
   * It should be called when either image or viewport size changes.
   *
   * @param {number} maxWidth
   * @param {number} maxHeight
   * @param {{ x?: number; y?: number }} panAreaSize
   */

/**
   * If this slide is active/current/visible
   *
   * @param {boolean} isActive
   */

/**
   * Initialize lightbox, should be called only once.
   * It's not included in the main constructor, so you may bind events before it.
   */

/**
   * Lazy load nearby slides based on `preload` option.
   *
   * @param {number=} diff Difference between slide indexes that was changed recently, or 0.
   */

/**
   * Position the scroller and slide containers
   * according to viewport size.
   *
   * @param {boolean=} resizeSlides Whether slides content should resized
   */

/**
   * Set this value to however many 'steps' you
   * want value-over-lifetime properties to have.
   *
   * It's adjustable to fix an interpolation problem:
   *
   * Assuming you specify an opacity value as [0, 1, 0]
   *      and the `valueOverLifetimeLength` is 4, then the
   *      opacity value array will be reinterpolated to
   *      be [0, 0.66, 0.66, 0].
   *   This isn't ideal, as particles would never reach
   *   full opacity.
   *
   * NOTE:
   *     This property affects the length of ALL
   *       value-over-lifetime properties for ALL
   *       emitters and ALL groups.
   *
   *     Only values >= 3 && <= 4 are allowed.
   *
   * @type {Number}
   */

/**
   * The Ease class provides a collection of easing functions for use with tween.js.
   */

/**
   * _getItemBounds
   *
   * @param {number} currZoomLevel
   */

/**
   * onComplete can be unpredictable, be careful about current state
   *
   * @param {AnimationProps} props
   */

/**
 *
 * @param {HTMLElement} element
 * @param {PhotoSwipe} pswp
 * @param {boolean=} isNextButton
 */

/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */

/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 */

/**
 * @param {HTMLElement} el
 * @param {number} imageWidth
 * @param {number} imageHeight
 */

/**
 * @param {HTMLElement} el
 */

/**
 * @param {PhotoSwipeOptions} options
 * @param {PhotoSwipe} pswp
 */

/**
 * @param {PhotoSwipeOptions} options
 * @param {{ x?: number; y?: number }} viewportSize
 * @param {SlideData} itemData
 * @param {number} index
 */

/**
 * @param {PhotoSwipe} pswp
 * @param {UIElementData} data
 */

/**
 * @param {Point} p
 */

/**
 * @param {Point} p1
 * @param {Point} p2
 */

/**
 * @param {UIElementMarkup} [htmlData]
 */

/**
 * @param {number} initialVelocity
 * @param {number} decelerationRate
 */

/**
 * @template T
 * @template P
 * @typedef {import('../types.js').AddPostfix<T, P>} AddPostfix<T, P>
 */

/**
 * @template T
 * @typedef {import('../core/eventable.js').EventCallback<T>} EventCallback<T>
 */

/**
 * @template T
 * @typedef {import('../types.js').Methods<T>} Methods<T>
 */

/**
 * @template T
 * @typedef {import('../types.js').Type<T>} Type<T>
 */

/**
 * @template {HTMLElementTagName | Falsy} [T="div"]
 * @template {Node | undefined} [NodeToAppendElementTo=undefined]
 * @param {string=} className
 * @param {T=} [tagName]
 * @param {NodeToAppendElementTo=} appendToEl
 * @returns {T extends HTMLElementTagName ? HTMLElementTagNameMap[T] : HTMLElementTagNameMap['div']}
 */

/**
 * @template {keyof PhotoSwipeEventsMap} T
 * @typedef {(event: AugmentedEvent<T>) => void} EventCallback<T>
 */

/**
 * @template {keyof PhotoSwipeEventsMap} T
 * @typedef {PhotoSwipeEventsMap[T] extends undefined ? PhotoSwipeEvent<T> : PhotoSwipeEvent<T> & PhotoSwipeEventsMap[T]} AugmentedEvent
 */

/**
 * @template {keyof PhotoSwipeFiltersMap} T
 * @typedef {{ fn: PhotoSwipeFiltersMap[T], priority: number }} Filter<T>
 */

/**
 * @typedef {Object} PhotoSwipeEventsMap https://photoswipe.com/events/
 *
 *
 * https://photoswipe.com/adding-ui-elements/
 *
 * @prop {undefined} uiRegister
 * @prop {{ data: UIElementData }} uiElementCreate
 *
 *
 * https://photoswipe.com/events/#initialization-events
 *
 * @prop {undefined} beforeOpen
 * @prop {undefined} firstUpdate
 * @prop {undefined} initialLayout
 * @prop {undefined} change
 * @prop {undefined} afterInit
 * @prop {undefined} bindEvents
 *
 *
 * https://photoswipe.com/events/#opening-or-closing-transition-events
 *
 * @prop {undefined} openingAnimationStart
 * @prop {undefined} openingAnimationEnd
 * @prop {undefined} closingAnimationStart
 * @prop {undefined} closingAnimationEnd
 *
 *
 * https://photoswipe.com/events/#closing-events
 *
 * @prop {undefined} close
 * @prop {undefined} destroy
 *
 *
 * https://photoswipe.com/events/#pointer-and-gesture-events
 *
 * @prop {{ originalEvent: PointerEvent }} pointerDown
 * @prop {{ originalEvent: PointerEvent }} pointerMove
 * @prop {{ originalEvent: PointerEvent }} pointerUp
 * @prop {{ bgOpacity: number }} pinchClose can be default prevented
 * @prop {{ panY: number }} verticalDrag can be default prevented
 *
 *
 * https://photoswipe.com/events/#slide-content-events
 *
 * @prop {{ content: Content }} contentInit
 * @prop {{ content: Content; isLazy: boolean }} contentLoad can be default prevented
 * @prop {{ content: Content; isLazy: boolean }} contentLoadImage can be default prevented
 * @prop {{ content: Content; slide: Slide; isError?: boolean }} loadComplete
 * @prop {{ content: Content; slide: Slide }} loadError
 * @prop {{ content: Content; width: number; height: number }} contentResize can be default prevented
 * @prop {{ content: Content; width: number; height: number; slide: Slide }} imageSizeChange
 * @prop {{ content: Content }} contentLazyLoad can be default prevented
 * @prop {{ content: Content }} contentAppend can be default prevented
 * @prop {{ content: Content }} contentActivate can be default prevented
 * @prop {{ content: Content }} contentDeactivate can be default prevented
 * @prop {{ content: Content }} contentRemove can be default prevented
 * @prop {{ content: Content }} contentDestroy can be default prevented
 *
 *
 * undocumented
 *
 * @prop {{ point: Point; originalEvent: PointerEvent }} imageClickAction can be default prevented
 * @prop {{ point: Point; originalEvent: PointerEvent }} bgClickAction can be default prevented
 * @prop {{ point: Point; originalEvent: PointerEvent }} tapAction can be default prevented
 * @prop {{ point: Point; originalEvent: PointerEvent }} doubleTapAction can be default prevented
 *
 * @prop {{ originalEvent: KeyboardEvent }} keydown can be default prevented
 * @prop {{ x: number; dragging: boolean }} moveMainScroll
 * @prop {{ slide: Slide }} firstZoomPan
 * @prop {{ slide: Slide, data: SlideData, index: number }} gettingData
 * @prop {undefined} beforeResize
 * @prop {undefined} resize
 * @prop {undefined} viewportSize
 * @prop {undefined} updateScrollOffset
 * @prop {{ slide: Slide }} slideInit
 * @prop {{ slide: Slide }} afterSetContent
 * @prop {{ slide: Slide }} slideLoad
 * @prop {{ slide: Slide }} appendHeavy can be default prevented
 * @prop {{ slide: Slide }} appendHeavyContent
 * @prop {{ slide: Slide }} slideActivate
 * @prop {{ slide: Slide }} slideDeactivate
 * @prop {{ slide: Slide }} slideDestroy
 * @prop {{ destZoomLevel: number, centerPoint: Point, transitionDuration: number | false }} beforeZoomTo
 * @prop {{ slide: Slide }} zoomPanUpdate
 * @prop {{ slide: Slide }} initialZoomPan
 * @prop {{ slide: Slide }} calcSlideSize
 * @prop {undefined} resolutionChanged
 * @prop {{ originalEvent: WheelEvent }} wheel can be default prevented
 * @prop {{ content: Content }} contentAppendImage can be default prevented
 * @prop {{ index: number; itemData: SlideData }} lazyLoadSlide can be default prevented
 * @prop {undefined} lazyLoad
 * @prop {{ slide: Slide }} calcBounds
 * @prop {{ zoomLevels: ZoomLevel, slideData: SlideData }} zoomLevelsUpdate
 *
 *
 * legacy
 *
 * @prop {undefined} init
 * @prop {undefined} initialZoomIn
 * @prop {undefined} initialZoomOut
 * @prop {undefined} initialZoomInEnd
 * @prop {undefined} initialZoomOutEnd
 * @prop {{ dataSource: DataSource, numItems: number }} numItems
 * @prop {{ itemData: SlideData; index: number }} itemData
 * @prop {{ index: number, itemData: SlideData, instance: PhotoSwipe }} thumbBounds
 */

/**
 * @typedef {Object} PhotoSwipeFiltersMap https://photoswipe.com/filters/
 *
 * @prop {(numItems: number, dataSource: DataSource) => number} numItems
 * Modify the total amount of slides. Example on Data sources page.
 * https://photoswipe.com/filters/#numitems
 *
 * @prop {(itemData: SlideData, index: number) => SlideData} itemData
 * Modify slide item data. Example on Data sources page.
 * https://photoswipe.com/filters/#itemdata
 *
 * @prop {(itemData: SlideData, element: HTMLElement, linkEl: HTMLAnchorElement) => SlideData} domItemData
 * Modify item data when it's parsed from DOM element. Example on Data sources page.
 * https://photoswipe.com/filters/#domitemdata
 *
 * @prop {(clickedIndex: number, e: MouseEvent, instance: PhotoSwipeLightbox) => number} clickedIndex
 * Modify clicked gallery item index.
 * https://photoswipe.com/filters/#clickedindex
 *
 * @prop {(placeholderSrc: string | false, content: Content) => string | false} placeholderSrc
 * Modify placeholder image source.
 * https://photoswipe.com/filters/#placeholdersrc
 *
 * @prop {(isContentLoading: boolean, content: Content) => boolean} isContentLoading
 * Modify if the content is currently loading.
 * https://photoswipe.com/filters/#iscontentloading
 *
 * @prop {(isContentZoomable: boolean, content: Content) => boolean} isContentZoomable
 * Modify if the content can be zoomed.
 * https://photoswipe.com/filters/#iscontentzoomable
 *
 * @prop {(useContentPlaceholder: boolean, content: Content) => boolean} useContentPlaceholder
 * Modify if the placeholder should be used for the content.
 * https://photoswipe.com/filters/#usecontentplaceholder
 *
 * @prop {(isKeepingPlaceholder: boolean, content: Content) => boolean} isKeepingPlaceholder
 * Modify if the placeholder should be kept after the content is loaded.
 * https://photoswipe.com/filters/#iskeepingplaceholder
 *
 *
 * @prop {(contentErrorElement: HTMLElement, content: Content) => HTMLElement} contentErrorElement
 * Modify an element when the content has error state (for example, if image cannot be loaded).
 * https://photoswipe.com/filters/#contenterrorelement
 *
 * @prop {(element: HTMLElement, data: UIElementData) => HTMLElement} uiElement
 * Modify a UI element that's being created.
 * https://photoswipe.com/filters/#uielement
 *
 * @prop {(thumbnail: HTMLElement, itemData: SlideData, index: number) => HTMLElement} thumbEl
 * Modify the thubmnail element from which opening zoom animation starts or ends.
 * https://photoswipe.com/filters/#thumbel
 *
 * @prop {(thumbBounds: Bounds, itemData: SlideData, index: number) => Bounds} thumbBounds
 * Modify the thubmnail bounds from which opening zoom animation starts or ends.
 * https://photoswipe.com/filters/#thumbbounds
 *
 * @prop {(srcsetSizesWidth: number, content: Content) => number} srcsetSizesWidth
 *
 */

/**
 * @typedef {Object} PoolItem
 * @prop {HTMLElement | Window | Document} target
 * @prop {string} type
 * @prop {(e: any) => void} listener
 * @prop {boolean} passive
 */

/**
 * @typedef {Object} UIElementData
 * @prop {DefaultUIElements | string} [name]
 * @prop {string=} className
 * @prop {UIElementMarkup=} html
 * @prop {boolean=} isButton
 * @prop {keyof HTMLElementTagNameMap} [tagName]
 * @prop {string=} title
 * @prop {string=} ariaLabel
 * @prop {(element: HTMLElement, pswp: PhotoSwipe) => void} [onInit]
 * @prop {Methods<PhotoSwipe> | ((e: MouseEvent, element: HTMLElement, pswp: PhotoSwipe) => void)} [onClick]
 * @prop {'bar' | 'wrapper' | 'root'} [appendTo]
 * @prop {number=} order
 */

/**
 * @typedef {Object} UIElementMarkupProps
 * @prop {boolean=} isCustomSVG
 * @prop {string} inner
 * @prop {string=} outlineID
 * @prop {number | string} [size]
 */

/**
 * A Track of Boolean keyframe values.
 */

/**
 * A Track of keyframe values that represent color.
 */

/**
 * A Track of numeric keyframe values.
 */

/**
 * A Track of quaternion keyframe values.
 */

/**
 * A Track of vectored keyframe values.
 */

/**
 * A Track that interpolates Strings
 */

/**
 * A compat function for `Quaternion.invert()` / `Quaternion.inverse()`.
 * `Quaternion.invert()` is introduced in r123 and `Quaternion.inverse()` emits a warning.
 * We are going to use this compat for a while.
 * @param target A target quaternion
 */

/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */

/**
 * Allow adding an arbitrary props to the Content
 * https://photoswipe.com/custom-content/#using-webp-image-format
 * @typedef {ContentDefault & Record<string, any>} Content
 */

/**
 * Apply CSS transition to element
 *
 * @param {HTMLElement} el
 * @param {string=} prop CSS property to animate
 * @param {number=} duration in ms
 * @param {string=} ease CSS easing function
 */

/**
 * Apply transform:translate(x, y) scale(scale) to element
 *
 * @param {HTMLElement} el
 * @param {number} x
 * @param {number=} y
 * @param {number=} scale
 */

/**
 * Apply width and height CSS properties to element
 *
 * @param {HTMLElement} el
 * @param {string | number} w
 * @param {string | number} h
 */

/**
 * Base PhotoSwipe event object
 *
 * @template {keyof PhotoSwipeEventsMap} T
 */

/**
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bézier_curve
 */

/**
 * Calculates minimum, maximum and initial (center) bounds of a slide
 */

/**
 * Calculates zoom levels for specific slide.
 * Depends on viewport size and image size.
 */

/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

/**
 * Check if browser is Safari
 *
 * @returns {boolean}
 */

/**
 * Check if click or keydown event was dispatched
 * with a special key or via mouse wheel.
 *
 * @param {MouseEvent | KeyboardEvent} e
 */

/**
 * Check if variable is PhotoSwipe class
 *
 * @param {any} fn
 */

/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */

/**
 * Depth-of-field post-process with bokeh shader
 */

/**
 * Depth-of-field shader with bokeh
 * ported from GLSL shader by Martins Upitis
 * http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html
 */

/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */

/**
 * Full-screen textured quad shader
 */

/**
 * Get center point between two points
 *
 * @param {Point} p
 * @param {Point} p1
 * @param {Point} p2
 */

/**
 * Get dimensions of thumbnail image
 * (click on which opens photoswipe or closes photoswipe to)
 *
 * @param {number} index
 * @param {SlideData} itemData
 * @param {PhotoSwipe} instance PhotoSwipe instance
 * @returns {Bounds | undefined}
 */

/**
 * Get transform string
 *
 * @param {number} x
 * @param {number=} y
 * @param {number=} scale
 */

/**
 * Handles single pointer dragging
 */

/**
 * Lazy-load an image
 * This function is used both by Lightbox and PhotoSwipe core,
 * thus it can be called before dialog is opened.
 *
 * @param {SlideData} itemData Data about the slide
 * @param {PhotoSwipe | PhotoSwipeLightbox | PhotoSwipeBase} instance PhotoSwipe instance
 * @param {number} index
 * @returns Image that is being decoded or false.
 */

/**
 * Lazy-loads specific slide.
 * This function is used both by Lightbox and PhotoSwipe core,
 * thus it can be called before dialog is opened.
 *
 * By default it loads image based on viewport size and initial zoom level.
 *
 * @param {number} index Slide index
 * @param {PhotoSwipe | PhotoSwipeLightbox} instance PhotoSwipe or PhotoSwipeLightbox eventable instance
 */

/**
 * Loader loads FBX file and generates Group representing FBX scene.
 * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format
 * Versions lower than this may load but will probably have errors
 *
 * Needs Support:
 *  Morph normals / blend shape normals
 *
 * FBX format references:
 * 	https://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure
 * 	http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)
 *
 * 	Binary format specification:
 *		https://code.blender.org/2013/08/fbx-binary-file-format-specification/
 */

/**
 * Luminosity
 * http://en.wikipedia.org/wiki/Luminosity
 */

/**
 * NURBS utils
 *
 * See NURBSCurve and NURBSSurface.
 **/

/**
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
 */

/**
 * Parse `gallery` or `children` options.
 *
 * @param {import('../photoswipe.js').ElementProvider} option
 * @param {string=} legacySelector
 * @param {HTMLElement | Document} [parent]
 * @returns HTMLElement[]
 */

/**
 * Parses padding option.
 * Supported formats:
 *
 * // Object
 * padding: {
 *  top: 0,
 *  bottom: 0,
 *  left: 0,
 *  right: 0
 * }
 *
 * // A function that returns the object
 * paddingFn: (viewportSize, itemData, index) => {
 *  return {
 *    top: 0,
 *    bottom: 0,
 *    left: 0,
 *    right: 0
 *  };
 * }
 *
 * // Legacy variant
 * paddingLeft: 0,
 * paddingRight: 0,
 * paddingTop: 0,
 * paddingBottom: 0,
 *
 * @param {'left' | 'top' | 'bottom' | 'right'} prop
 * @param {PhotoSwipeOptions} options PhotoSwipe options
 * @param {{ x?: number; y?: number }} viewportSize PhotoSwipe viewport size, for example: { x:800, y:600 }
 * @param {SlideData} itemData Data about the slide
 * @param {number} index Slide index
 * @returns {number}
 */

/**
 * PhotoSwipe Lightbox
 *
 * - If user has unsupported browser it falls back to default browser action (just opens URL)
 * - Binds click event to links that should open PhotoSwipe
 * - parses DOM strcture for PhotoSwipe (retrieves large image URLs and sizes)
 * - Initializes PhotoSwipe
 *
 *
 * Loader options use the same object as PhotoSwipe, and supports such options:
 *
 * gallery - Element | Element[] | NodeList | string selector for the gallery element
 * children - Element | Element[] | NodeList | string selector for the gallery children
 *
 */

/**
 * PhotoSwipe base class that can listen and dispatch for events.
 * Shared by PhotoSwipe Core and PhotoSwipe Lightbox, extended by base.js
 */

/**
 * PhotoSwipe base class that can retrieve data about every slide.
 * Shared by PhotoSwipe Core and PhotoSwipe Lightbox
 */

/**
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */

/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */

/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */

/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */

/**
 * References:
 * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html
 * https://learnopengl.com/Advanced-Lighting/SSAO
 * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl
 */

/**
 * Returns distance between two points.
 *
 * @param {Point} p1
 * @param {Point} p2
 */

/**
 * Set special class on element when image is zoomed.
 *
 * By default it is used to adjust
 * zoom icon and zoom cursor via CSS.
 *
 * @param {HTMLElement} el
 * @param {boolean} isZoomedIn
 */

/**
 * Spherical linear unit quaternion interpolant.
 */

/**
 * Tap, double-tap handler.
 */

/**
 * The float result between the min and max values.
 *
 * @param {number} val
 * @param {number} min
 * @param {number} max
 */

/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 */

/**
 * Uniform Utilities
 */

/**
 * Uniforms library for shared webgl shaders
 */

/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */

/**
 * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a
 * mip map chain of bloom textures and blurs them with different radii. Because
 * of the weighted combination of mips, and because larger blurs are done on
 * higher mips, this effect provides good quality and performance.
 *
 * Reference:
 * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/
 */

/**
 * Utility class for sampling weighted random points on the surface of a mesh.
 *
 * Building the sampler is a one-time O(n) operation. Once built, any number of
 * random samples may be selected in O(logn) time. Memory usage is O(n).
 *
 * References:
 * - http://www.joesfer.com/?p=84
 * - https://stackoverflow.com/a/4322940/1314762
 */

/**
 * WebGL port of Subpixel Morphological Antialiasing (SMAA) v2.8
 * Preset: SMAA 1x Medium (with color edge detection)
 * https://github.com/iryoku/smaa/releases/tag/v2.8
 */

/**
 * Whether X and Y positions of points are qual
 *
 * @param {Point} p1
 * @param {Point} p2
 */

/**
 * Whether the tap was performed on the main slide
 * (rather than controls or caption).
 *
 * @param {PointerEvent} event
 */

/**
 * You can pass in a random number generator object if you like.
 * It is assumed to have a random() method.
 */

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

/**
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

/**
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */

/**
 * parameters = {
 *  clearcoat: <float>,
 *  clearcoatMap: new THREE.Texture( <Image> ),
 *  clearcoatRoughness: <float>,
 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
 *  clearcoatNormalScale: <Vector2>,
 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
 *
 *  reflectivity: <float>,
 *  ior: <float>,
 *
 *  sheen: <Color>,
 *
 *  transmission: <float>,
 *  transmissionMap: new THREE.Texture( <Image> )
 * }
 */

/**
 * parameters = {
 *  color: <THREE.Color>
 * }
 */

/**
 * parameters = {
 *  color: <hex>,
 *
 *  map: new THREE.Texture( <Image> ),
 *  gradientMap: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

/**
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 *
 *  flatShading: <bool>
 * }
 */

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */

/**
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  flatShading: <bool>
 * }
 */

/**
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.MultiplyOperation,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  flatShading: <bool>
 * }
 */

/**
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

/**
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  flatShading: <bool>
 * }
 */

/** @class */

/** @private */

/** @type HTMLImageElement */

/** @type {'initialZoomIn' | 'initialZoomOut'} */

/** @type {'initialZoomInEnd' | 'initialZoomOutEnd'} */

/** @type {'initialZoomLevel' | 'secondaryZoomLevel' | 'maxZoomLevel'} */

/** @type {'x' | 'y'} */

/** @type {() => Promise<Type<PhotoSwipe>>} */

/** @type {() => void} */

/** @type {(UIElement | UIElementData)[]} */

/** @type {(keyof PhotoSwipeEventsMap)[]} */

/** @type {(keyof PhotoSwipeFiltersMap)[]} */

/** @type {AddPostfix<Actions, 'Action'>} */

/** @type {AnimationProps} */

/** @type {Animation[]} */

/** @type {Animations} */

/** @type {Animation} */

/** @type {AugmentedEvent<T>} */

/** @type {Content[]} */

/** @type {EventCallback<typeof name>} */

/** @type {HTMLAnchorElement} */

/** @type {HTMLButtonElement} */

/** @type {HTMLDivElement} */

/** @type {HTMLElement[]} */

/** @type {HTMLElement} */

/** @type {HTMLImageElement | HTMLDivElement} */

/** @type {HTMLImageElement} */

/** @type {ItemHolder[]} */

/** @type {LoadState} */

/** @type {Methods<PhotoSwipe>} */

/** @type {NodeJS.Timeout} */

/** @type {Node} */

/** @type {PhotoSwipe=} */

/** @type {PhotoSwipeOptions} */

/** @type {PhotoSwipeOptions}*/

/** @type {Point[]} */

/** @type {PointerEvent} */

/** @type {Point} */

/** @type {Promise<Type<PhotoSwipe>>[]} */

/** @type {SlideData} */

/** @type {Slide} */

/** @type {TouchEvent} */

/** @type {Type<PhotoSwipe>} */

/** @type {UIElementData[]} */

/** @type {UIElementData} */

/** @type {boolean} */

/** @type {false | Bounds} */

/** @type {keyof HTMLElementTagNameMap} */

/** @type {number} */

/** @type {string} */

/** @type {{ IDLE: 'idle'; LOADING: 'loading'; LOADED: 'loaded'; ERROR: 'error' }} */

/** @typedef {'arrowPrev' | 'arrowNext' | 'close' | 'zoom' | 'counter'} DefaultUIElements */

/** @typedef {'fit' | 'fill' | number | ((zoomLevelObject: ZoomLevel) => number)} ZoomLevelOption */

/** @typedef {'imageClick' | 'bgClick' | 'tap' | 'doubleTap'} Actions */

/** @typedef {'x' | 'y'} Axis */

/** @typedef {LOAD_STATE[keyof LOAD_STATE]} LoadState */

/** @typedef {import("../photoswipe.js").PhotoSwipeOptions} PhotoSwipeOptions */

/** @typedef {import("../photoswipe.js").default} PhotoSwipe */

/** @typedef {import("../slide/slide.js").SlideData} SlideData */

/** @typedef {import('../core/eventable.js').PhotoSwipeEventsMap} PhotoSwipeEventsMap */

/** @typedef {import('../core/eventable.js').PhotoSwipeFiltersMap} PhotoSwipeFiltersMap */

/** @typedef {import('../lightbox/lightbox.js').default} PhotoSwipeLightbox */

/** @typedef {import('../photoswipe.js').DataSource} DataSource */

/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */

/** @typedef {import('../photoswipe.js').Point} Point */

/** @typedef {import('../photoswipe.js').default} PhotoSwipe */

/** @typedef {import('../slide/content.js').default} Content */

/** @typedef {import('../slide/content.js').default} ContentDefault */

/** @typedef {import('../slide/get-thumb-bounds.js').Bounds} Bounds */

/** @typedef {import('../slide/slide.js').SlideData} SlideData */

/** @typedef {import('../slide/slide.js').default} Slide */

/** @typedef {import('../slide/zoom-level.js').default} ZoomLevel */

/** @typedef {import('../ui/ui-element.js').UIElementData} UIElementData */

/** @typedef {import('./gestures.js').default} Gestures */

/** @typedef {import('./slide.js').SlideData} SlideData */

/** @typedef {import('./slide.js').default} Slide */

/** @typedef {import('./ui-element.js').UIElementData} UIElementData */

/** @typedef {keyof HTMLElementTagNameMap} HTMLElementTagName */

/** @typedef {string | UIElementMarkupProps} UIElementMarkup */

/** @typedef {undefined | null | false | '' | 0} Falsy */

/** @typedef {{ x: number; y: number; w: number; innerRect?: { w: number; h: number; x: number; y: number } }} Bounds */

/** @typedef {{ x?: number; y?: number }} Point */

/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

/**************************************************************
 *	NURBS Utils
 **************************************************************/

/************************************************************************/

/******/

/***/

/*, deltaTime, maskActive */

/*, deltaTime, maskActive*/

/*, readBuffer, deltaTime, maskActive */

/*, t0, t, t1 */

/*, writeBuffer, readBuffer, deltaTime, maskActive */

/*@__PURE__*/

/*Array of Vector*/

//

//	 "/9j/4RDaRXhpZgAATU0A..."

//	(seems like some exporters embed fixed 15 or 16bytes?)

//	- t [0 .. 1]

//	Content: ,

//	const texture = new THREE.DataTexture3D( data, width, height, depth );

//	content/SpinCalc.m

// 	- the identifier (member name or array index)

// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/

// 	DynamicDrawUsage :

// 	StaticDrawUsage;

// 	actionByRoot: AnimationAction - lookup

// 	knownActions: Array< AnimationAction > - used as prototypes

// 	texture.anisotropy = 16;

//                  <-swap->

//                 a        s

//                 s        a

//         <-swap->

//        a        s

//        s        a

//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)

//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)

//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)

//      via event or some class or something

//     continue;

//     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;

//     r

//     result = -( randomise ? Math.random() * epsilon * 10 : epsilon );

//     result = randomise ? Math.random() * epsilon * 10 : epsilon;

//     return animation.props.isMainScroll;

//     utils.ensureTypedArg( options.wiggle.randomise, types.BOOLEAN, !!options.wiggle.spread ),

//    (up to 54 should be safe)

//   <circle ... />

//   <path d="..." />

//   and velocity is close to 0

//   and we see at least tiny part of the next slide

//   centerPoint = pswp.getViewportCenterPoint();

//   return this.activeAnimations.some((animation) => {

//   shifted by 1 unit (length of normalized vector) to the left

//   transitionDuration = this.pswp.options.zoomAnimationDuration;

//   y Y

//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))

//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))

//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)

//   });

//  (j)---(i)---(k)

//  - Trigger event if count === 0.

//  - Trigger event if count === this.particleCount.

//  - followed by an optional left bracket or dot (type of subscript)

//  - followed by an optional right bracket (found when array index)

//  - leave some extra space for other uniforms

//  - limit here is ANGLE's 254 max uniform vectors

//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5

//  adjacent edges of inPt at a distance of 1 unit on the left side.

//  but prevent crazy spikes

//  it animates all properties with single timing function)

//  not counting lowerY endpoints of edges and whole edges on that line

//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)

//  with the horizontal line through inPt, left of inPt

//  xzXZ

//  }

// #ff0

// #ff0000

// '',

// 'accu0' and 'accu1' are used frame-interleaved for

// 'add' is used for additive cumulative results

// 'bar' could be the objectName, or part of a nodeName (which can

// 'nActiveActions' followed by inactive ones

// 'nActiveBindings' followed by inactive ones

// 'orig' stores the original state of the property

// 'text' or other

// 'work' is optional and is only present for quaternion types. It is used

// ( 2 * π / 3 ) * 0.488603

// ( for example when prebuilding shader to be used with multiple objects )

// ( π / 4 ) * 0.315392 * 3

// ( π / 4 ) * 0.546274

// ( π / 4 ) * 1.092548

// (#8465, #8379)

// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)

// (a) intensity is the total visible light emitted

// (also flipping doesn't work for compressed textures )

// (b) intensity is the brightness of the light

// (correctZoomPan does not have this functionality,

// (developer may modify it via public API)

// (do they same as object-fit:cover does to retrieve coordinates)

// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)

// (if user clicked on another gallery item before current was loaded).

// (instead of changing width/height directly).

// (just using requestanimationframe is not enough in Firefox,

// (per vertex tangents)

// (result of 0 * Infinity). x !== x returns true if x is NaN

// (shader material also gets them for the sake of genericity)

// (stretched thumbnail or simple div behind the main image)

// (that must be a problem of the original one though)

// (the one that allows to save image or open it in new tab).

// (to be used with above comparison fns)

// (usually happens if stopped in the middle of animation)

// ************** UTILITY FUNCTIONS **************

// *Layout* - calculate size and position of elements here

// + 1, using the scan for the details

// - 120bytes: zero

// - 16bytes: magic

// - 4bytes: magic

// - 4bytes: version

// - The closest point on the ray

// - The closest point on the segment

// - http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/

// - if velocity and its direction is matched

// - or if we see less than 50% of the current slide

// - padding til 16-byte alignment (at least 1byte?)

// - u [0 .. 1]

// --- Protected interface

// --- Setters ---

// --- Top-level ---

// --- Uniform Classes ---

// --enable-privileged-webgl-extension

// -> XYZ extrinsic

// -> XZY extrinsic

// -> YXZ extrinsic

// -> YZX extrinsic

// -> ZXY extrinsic

// ...assume THREE.Math-ish

// ...assume skeletal animation

// .toUpperCase() here flattens concatenated strings to save heap memory space.

// 0

// 0 - slide is not visible at all,

// 0 - start of animation, 1 - end of animation

// 0 - start, 1 - end

// 0.5 - half of the slide is vicible

// 0.9 is somewhat arbitrary

// 000

// 001

// 010

// 011

// 0: repeat(default), 1: clamp

// 1 - slide is fully visible

// 1 << 32 will return 1 so using multiply operation instead here.

// 1. Extract Bright Areas

// 1. Length of each sub path have to be known

// 1. color map

// 1. you need three indices to draw a single face

// 10. clearcoat map

// 100

// 101

// 11. clearcoat normal map

// 110

// 111

// 12. clearcoat roughnessMap map

// 18 - average line height

// 2 finger pinch

// 2 points a small delta apart will be used to find its gradient

// 2. Blur All the mips progressively

// 2. Locate and identify type of curve

// 2. a single segment consists of two faces

// 2. alpha map

// 2. specular map

// 3-band SH defined by 9 coefficients

// 3. Get t for the curve

// 3. displacementMap map

// 3. so we need to generate six (2*3) indices per segment

// 3D simplex noise

// 3x of "fit" state, but not larger than original

// 4 floats per RGBA pixel

// 4 is required to match default unpack alignment of 4.

// 4 pixels needed for 1 matrix

// 4 points (p1 & p2 defined below)

// 4. Return curve.getPointAt(t')

// 4. normal map

// 4D simplex noise

// 5. bump map

// 500

// 6. roughnessMap map

// 7. metalnessMap map

// 8. alphaMap map

// 9. emissiveMap map

// </svg>

// <svg viewBox="0 0 32 32" width="32" height="32" aria-hidden="true" class="pswp__icn">

// > it's probably wise to use the same values used for the call to `addEventListener()` when calling `removeEventListener()`

// ??

// @ts-expect-error

// @ts-expect-error lookup only by `data.name` maybe?

// @ts-expect-error should provide pswp instance?

// @ts-ignore

// @ts-ignore FIXME?

// A cube with quad faces looks like this:

// A lookup table to traverse the simplex around a given point in 4D.

// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and

// A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),

// AKA glossiness map

// AKA specularLevel

// API

// ASCII format

// Accumulate weights for each mesh face.

// Add a line curve if start and end of lines are not connected

// Add bevel segments planes

// Add content to the previous and next slide

// Add contributions from each corner to get the final noise value.

// Add custom-defined promise, if any

// Add placeholder to DOM if it was already created

// Add some defines into the mix...

// Add stepped vertices...

// Add the main module

// Add to cache only on HTTP success, so that we do not cache

// Add to identity for additive

// Add to the events pool

// Added 4D noise

// Adjust starting point

// Adjust starting points

// All uniforms used by vertex / fragment shaders

// Allow developers to provide full svg,

// Allow dragging only via left mouse button.

// Allow to override SVG icons from options

// Allows you to seek to a specific time in an animation.

// Also changing the encoding after already used by a Material will not automatically make the Material

// Also parse the texture map and return any textures associated with the material

// Always move main scroll if image can not be panned

// And these for the searches, they indicate the ends of the loops:

// Angle above the XZ plane.

// Angle around the Y axis, counter-clockwise when looking from above.

// Animate opacity of background relative to Y pan position of an image

// Animation Loop

// Appearance

// Apply friction

// Apply perpective to pointSize value

// Apply radius scale to this position

// Apply styles before opening transition

// Apply the friction if zoom level is above the max

// Apply the friction if zoom level is below the min

// Array of matrices (flat or from THREE clases)

// Array of scalars

// Array of textures (2D / Cube)

// Array of vectors (flat or from THREE classes)

// ArrayElement

// As another texture upload may have changed pixelStorei

// As progress ratio can be larger than 1 due to overshoot,

// Assign a UUID to this instance

// Assign color to vColor varying.

// Assign inputSources to available controllers

// Assume one model and get the preRotation from that

// Avoid appending heavy elements during animations

// Avoid blurred poles

// Avoid the String.fromCharCode.apply(null, array) shortcut, which

// Back facing vertices

// Background is added as a separate element,

// Based on http://www.gamedev.net/reference/articles/article1199.asp

// Binary Format

// Bind click events to each gallery

// Blend it additively over the input texture

// Bottom faces

// Branch-avoiding logical operators

// Buffer deallocation

// Buffer rendering

// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)

// By defaul it is center of viewport:

// CAUTION: these props must append to parent's parent

// CONCATENATED MODULE: ./libs/photoswipe/photoswipe-lightbox.esm.js

// CONCATENATED MODULE: ./libs/photoswipe/photoswipe.esm.js

// CONCATENATED MODULE: ./main.js

// CONCATENATED MODULE: ./modules/mod.content.js

// CONCATENATED MODULE: ./modules/mod.gallery.js

// CONCATENATED MODULE: ./modules/mod.interaction.js

// CONCATENATED MODULE: ./modules/mod.multiverse.js

// CONCATENATED MODULE: ./modules/mod.postprocessing.js

// CONCATENATED MODULE: ./node_modules/camera-controls/dist/camera-controls.module.js

// CONCATENATED MODULE: ./node_modules/detect-gpu/dist/detect-gpu.esm.js

// CONCATENATED MODULE: ./node_modules/three/examples/jsm/curves/NURBSUtils.js

// CONCATENATED MODULE: ./node_modules/three/examples/jsm/libs/fflate.module.min.js

// CONCATENATED MODULE: ./node_modules/three/examples/jsm/loaders/FBXLoader.js

// CONCATENATED MODULE: ./node_modules/three/examples/jsm/math/MeshSurfaceSampler.js

// CONCATENATED MODULE: ./node_modules/three/examples/jsm/math/SimplexNoise.js

// CONCATENATED MODULE: ./node_modules/three/examples/jsm/postprocessing/BokehPass.js

// CONCATENATED MODULE: ./node_modules/three/examples/jsm/postprocessing/EffectComposer.js

// CONCATENATED MODULE: ./node_modules/three/examples/jsm/postprocessing/MaskPass.js

// CONCATENATED MODULE: ./node_modules/three/examples/jsm/postprocessing/Pass.js

// CONCATENATED MODULE: ./node_modules/three/examples/jsm/postprocessing/RenderPass.js

// CONCATENATED MODULE: ./node_modules/three/examples/jsm/postprocessing/ShaderPass.js

// CONCATENATED MODULE: ./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js

// CONCATENATED MODULE: ./node_modules/three/examples/jsm/shaders/BokehShader.js

// CONCATENATED MODULE: ./node_modules/three/examples/jsm/shaders/CopyShader.js

// CONCATENATED MODULE: ./node_modules/three/examples/jsm/shaders/LuminosityHighPassShader.js

// CONCATENATED MODULE: ./node_modules/three/examples/jsm/shaders/SMAAShader.js

// CONCATENATED MODULE: ./node_modules/three/examples/jsm/shaders/SSAOShader.js

// Calculate color deltas:

// Calculate handedness

// Calculate left-left and top-top deltas:

// Calculate right and bottom deltas:

// Calculate the final maximum delta:

// Calculate the local transform matrix

// Calculate the maximum delta in the direct neighborhood:

// Cameras and other Object3Ds

// Can also be any HTML string.

// Cancel opening if UID doesn't match the current one

// Capping in case of danger

// Case where FBX wraps shading model in property object.

// Characters [].:/ are reserved for track binding syntax.

// Check boundingBox before continuing

// Check for data: URI

// Check if an Array was provided as property value

// Check if code has been already compiled

// Check if module is in cache

// Check if reader has reached the end of content.

// Check if request is duplicate

// Check if the gallery is already open

// Check if the user has installed THREE

// Check if two taps were more or less on the same place

// Check pinchz

// Check the last frame we updated the VideoTexture

// Checking boundingSphere distance to ray

// Chrome does this automatically, Firefox and Safari do not,

// Clean up

// Clear references from inactive renderItems in the list

// Clearing

// Collect influences

// Compile

// Composite All the mips

// Composite material

// Compute lengths and cache them

// Compute the offset origin, edges, and normal.

// Computes the world-axis-aligned bounding box of an object (including its children),

// Condition that's most likely to be true at the top: no change.

// Conjugate the quaternion

// Connections

// Convert [seconds, nanoseconds] to milliseconds.

// Convert pos to a world-space value

// Convert the material indices of each vertex into rendering groups on the geometry.

// Converts FBX ticks into real time seconds.

// Coordinates of inner crop area

// Crashes in iOS9 and iOS10. #18402

// Create a DirectionalLight, PointLight or SpotLight

// Create a copy of the buffer. The `decodeAudioData` method

// Create a local copy of the Array with the start value at the front

// Create a new module (and put it into the cache)

// Create faces for the z-sides of the shape

// Create particle group and emitter

// Create placeholder

// Create properties for use by the emitter pooling functions.

// Create the BufferGeometry and Points instances, ensuring

// Create the ShaderMaterial instance that'll help render the

// Custom events

// DECLARE ALIAS AFTER assign prototype

// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.

// DONE

// Datasource is an array of elements

// David Eberly's algorithm for finding a bridge between hole and outer polygon

// Debug configuration container

// Default position of element.

// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here

// Depth stencil textures need the DEPTH_STENCIL internal format

// Desktop Safari allows to drag images when preventDefault isn't called on mousedown,

// Destroy is called automatically onFinish

// Destroy the first content that's not attached

// Details can be found where this table is used, in the 4D noise method.

// Detect passive event listener support

// Determine angle

// Determine color and opacity for this particle

// Determine perspective

// Determine point size.

// Deterministic pseudo-random float in the interval [ 0, 1 ]

// Dialog was likely opened by keyboard if initial point is not defined

// Direct

// Directional

// DirectionalLight, SpotLight

// Disable delay if there is no doubleTapAction

// Disambiguate the length added by the last step:

// Discard animations when duration is less than 50ms

// Dispatching the itemData event,

// Do not allow click event to pass through after drag

// Do not trigger tap events if main scroll is shifted

// Do not trigger tap for touchcancel or pointercancel

// Don't call `event.preventDefault()` on the pointerdown event

// Don't create it if it already exists, but do

// Don't normalize!, otherwise sharp corners become ugly

// Don't re-activate particles that aren't dead yet.

// Don't update properties that do not exist in the source object

// Drag axis was detected, emit drag.start

// Due to Safari feature, we must define sizes before srcset.

// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by

// ESM COMPAT FLAG

// EXPORTS

// EXTERNAL MODULE: ./modules/mod.particles.js

// EXTERNAL MODULE: ./node_modules/three/build/three.module.js

// Each skin node represents a skeleton and each cluster node represents a bone

// Edge at north

// Edge at west

// Empty sphere produces empty bounding box

// Ensure depth buffer writing is enabled so it can be cleared on next render

// Ensure we have a map of options to play with

// EntireArray

// Events

// Events pool is used to easily unbind all events when PhotoSwipe is closed,

// Execute the module function

// Exit and allow default browser action if:

// Exit if pan position should not be changed

// Exposed for resource monitoring & error feedback via renderer.info:

// FBX does not list materials for Nurbs lines, so we'll just put our own in here.

// FBX format currently only supports Lambert and Phong shading models

// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)

// FLOAT

// Face index and vertex index arrays are combined in a single array

// Fallback filters for non-power-of-2 textures

// Fetch the blending weights for current pixel:

// Fetch the bottom crossing edges:

// Fetch the opposite color and lerp by hand:

// Fetch the right crossing edges:

// Fetch the top crossing edges:

// Finalize the animation

// Find directions for point movement

// Find the distance to the bottom:

// Find the distance to the left:

// Find the distance to the right:

// Find the distance to the top:

// Find the point on the AABB closest to the sphere center.

// Find the track in the target clip whose name and type matches the reference track

// Find the union of the frustum values of the cameras and scale

// Find the value to subtract out of the track

// First, ensure both properties are arrays.

// Flag the module as loaded

// Flattening for arrays of vectors and matrices

// For all animated objects, times are defined separately for each axis

// For example:

// For faster and easier lookups

// Force a particular attribute to index 0.

// Force-append new slides during transition

// Fragment chunks

// Free WebGL resources

// GLSL 3.0 conversion for built-in materials and ShaderMaterial

// GLSL shader uses formula baseinfluence * base + sum(target * influence)

// Gaussian Blur Materials

// Generate a BufferGeometry from a node in FBXTree.Objects.Geometry

// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry

// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris

// Generate mipmap if we're using any kind of mipmap filtering

// Generate mipmaps only when copying level 0

// Generates map of Skeleton-like objects for use later when generating and binding skeletons.

// Get length of sub-curve

// Get list of cumulative segment lengths

// Get point at relative position in curve according to arc length

// Get sequence of points using getPoint( t )

// Get sequence of points using getPointAt( u )

// Get the area for this direction:

// Get total curve arc length

// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

// Global Rotation

// Global Shear*Scaling

// Go next slide.

// Go to next slide

// Go to prev slide

// Golden Ratio

// Gram-Schmidt orthogonalize

// Hack #15830

// Handle main scroll if it's shifted

// Handle srcset sizes attribute.

// Handle vertical drag to close

// Handles WebGL2 RGBFormat fallback - #18858

// HasToFromArray

// Helper for passes that need to fill the viewport with a single quad.

// Helper to pick the right setter for a pure (bottom-level) array

// Helper to pick the right setter for the singular case

// Here we'll combine the times into one sorted array without duplicates

// Holds (alive, age, delay, wiggle)

// Holds a reference to the params attribute's typed array

// Holds a reference to this emitter's group once

// Holds a reference to this emitter's group's attributes object

// Holds the number of currently-alive particles

// Holds the time the emitter has been alive for.

// How far should user should drag

// How far you can dolly in and out ( PerspectiveCamera only )

// However, if the removed tween was added during the current batch,

// However, they are placed offscreen (to the left and right side).

// Huge thanks to:

// I wasn't able to reach it, but just to be safe.

// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values

// INT, BOOL

// INT_SAMPLER_2D

// INT_SAMPLER_2D_ARRAY

// INT_SAMPLER_3D

// INT_SAMPLER_CUBE

// Icon itself and border are styled via CSS.

// Icons may contain outline/shadow,

// If `to()` specifies a property that doesn't exist in the source object,

// If both clientX and clientY are 0 or not defined,

// If main scroll is shifted

// If main scroll is shifted right

// If no `deltaTime` value is passed to the `SPE.Group.tick` function,

// If pointer lock is enabled, use the Delta directory, and assume active-pointer is not multiple.

// If tapTimer is defined - we tapped recently,

// If that point is inside the sphere, the AABB and sphere intersect.

// If the arg isn't an array then just fallback to

// If the argument being checked is an array, loop through

// If the emitter has a specified lifetime and we've exceeded it,

// If the emitter is dead, reset the age of the emitter to zero,

// If this particle is using a sprite-sheet as a texture, we'll have to figure out

// If uniforms are marked as clean, they don't need to be loaded to the GPU.

// If we are above and moving upwards,

// If we are out of pan bounds

// If we move above - the ratio is negative

// If we move below the ratio is positive

// If we were reversed (f.e. using the yoyo feature) then we need to

// If you remove a tween during an update, it may or may not be updated.

// Ignore any errors

// Ignore background in AR

// Ignore unused materials which don't have any connections.

// Implicitly assumes little-endian.

// Important: It's actually a hack to put FullScreenQuad into the Pass namespace. This is only

// In case any sub curve does not implement its tangent derivation,

// In cases where a bone is shared between multiple meshes

// In iOS webview, if element size depends on document size,

// In node.js, use process.hrtime.

// In previous versions we also bound mouse event here,

// In the next minor release, I may well remove this check and force

// Include a performance.now polyfill.

// Including front facing vertices

// Increment age

// Increment age for those particles that are alive,

// Increment the active particle count.

// Increment the age of the emitter.

// Initial and secondary zoom levels are almost equal

// Initialise array for duplicate requests

// Inspired by Apple Webkit and Android spring function implementation

// Integer / Boolean vectors or arrays thereof (always flat arrays)

// Interna

// Internal interface used by befriended PropertyBinding.Composite:

// Interpolant argument to constructor is not saved, so copy the factory method directly.

// Interpolate to the reference value

// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

// Is there any blending weight with a value greater than 0.0?

// It can also set two optional targets :

// It returns the min distance between the ray and the segment

// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.

// JavaScript doesn't support 64-bit integer so calculate this here

// Keep initial zoom level if it was before the resize,

// Legacy

// LightType can be undefined for Point lights

// Line curve is linear, so we can overwrite default getPointAt

// Line intersects triangle, check if ray does.

// Linear mapping from range <a1, a2> to range <b1, b2>

// Load entry module and return exports

// Local contrast adaptation in action:

// Loop bevelSegments, 1 for the front, 1 for the back

// Main scroll is shifted left (Position is less than 0 comparing to the viewport 0)

// Make a copy, in case listeners are removed while iterating.

// Make each track's values relative to the values at the reference frame

// Make sure the typedArray is present and correct.

// Make the chained tweens start exactly at the time they should,

// Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w

// Map of all attributes to be applied to the particles.

// Map of uniforms to be applied to the ShaderMaterial instance.

// Mark the particle as alive.

// Materials are connected to texture maps in FBXTree.Objects.Textures

// Maybe we should also check if holes are in the opposite direction, just to be safe ...

// Memory management for AnimationAction objects

// Memory management for PropertyMixer objects

// Memory management of Interpolants for weight and time scale

// Memory manager

// Minimum at interior points of ray and segment.

// Mouse Event

// Move the activation window forward, soldier.

// Move to proper place, according to the subpixel offset:

// Multiply the conjugate for quaternion track types

// NAMESPACE OBJECT: ./node_modules/three/examples/jsm/libs/fflate.module.min.js

// NOTE: I am using a binary pattern to specify all 2^3 combinations below

// NOTE: Seems to be a copy of DisplacementColor

// Nearby slide images are in DOM and not hidden via display:none.

// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3

// Never lower quality, if it was increased previously.

// Node

// Noise contributions from the four corners

// Noise contributions from the three corners

// Normal and position attributes only have data for the vertices that are affected by the morph

// Normalize in case we just did a lerp:

// Not required if searchTex accesses are set to point:

// Not using Line*Material

// Not using update ranges

// Note that some screen readers emulate the mouse position,

// Note that the new renderState won't apply until the next frame. See #18320

// Note: Defining these methods externally, because they come in a bunch

// Note: The indirection allows central control of many interpolants.

// Note: These portions can be read in a non-overlapping fashion and

// Note: see getInt64() comment

// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

// Note: will lead to a divide by zero if the plane is invalid.

// Notify connected

// Notify disconnected

// Now fetch the left crossing edges, two at a time using bilinear

// Null is preferable to undefined since undefined means.... it is undefined

// Number of standard deviations at which to cut off the discrete approximation.

// Object Accessors

// Object names must be checked against an allowlist. Otherwise, there

// Object.prototype.hasOwnProperty.call

// Offsets for middle corner in (x,y) unskewed coords

// Offsets for second (middle) corner of simplex in (i,j) coords

// Offsets for second corner in (x,y,z) coords

// Offsets for third corner of simplex in (i,j,k) coords

// Ok, we know how this pattern looks like, now it is time for getting

// Only do angle calculation if there's no spritesheet defined.

// Or if shouldOpen flag is set to false

// Orthographic

// Otherwise transform will keep growing indefinitely,

// Overdamped (>1) damping ratio is not supported

// Override initial zoom and pan position

// Overshoot if the final position is out of pan bounds

// P: "Lcl Scaling", "Lcl Scaling", "", "A",1,1,1

// PI, so we'll interpolate large rotations

// Pan position with corrected bounds

// Pan transition might be running (and consntantly updating pan position)

// Park-Miller algorithm

// Parse FBX material and return parameters suitable for a three.js material

// Parse FBXTree.Objects.Video for embedded image data

// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists

// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists

// Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light

// Parse an FBX file in Binary format

// Parse embedded image data in FBXTree.Video.Content

// Parse individual node in FBXTree.Objects.Texture

// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists

// Parse nodes in FBXTree.Objects.Deformer

// Parse nodes in FBXTree.Objects.Geometry

// Parse nodes in FBXTree.Objects.Material

// Parse nodes in FBXTree.Objects.Texture

// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists

// Parse single node in FBXTree.Objects.Geometry

// Parse single node in FBXTree.Objects.Material

// Parse single node mesh geometry in FBXTree.Objects.Geometry

// Parse single nodes in FBXTree.Objects.Deformer

// Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group

// Parser - builds up the property tree from the path strings

// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )

// Parses comma separated list of numbers and returns them an array.

// Parses relative end values with start as base (e.g.: +10, -3)

// Perspective

// PhotoSwipe is already open

// PhotoSwipe keeps track only of two pointers, others are ignored

// Pivots and offsets

// Point

// PolygonVertexIndex: *24 {

// Ported from Stefan Gustavson's java implementation

// Position of the main scroll relative to the viewport

// Position on the main scroller (offset)

// Properties are used when animation from cropped thumbnail

// Property shadowID defines ID of element that should be cloned.

// Protect against non numeric properties.

// Pull back the camera depth that has moved, to be the camera stationary as zoom

// Push sums into cached array

// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

// Random float from <-range/2, range/2> interval

// Random float from <low, high> interval

// Random integer from <low, high> interval

// Ratio between 0 and 1:

// Ray and segment are parallel.

// Ray intersects triangle.

// Read Stefan's excellent paper for details on how this code works.

// Reassign starting values, restart by making startTime = now

// Ref: https://github.com/cedricpinson/osgjs/blob/00e5a7e9d9206c06fdde0436e1d62ab7cb5ce853/sources/osgViewer/input/source/InputSourceMouse.js#L89-L103

// Refer to #5689 for the reason why we don't set .onStart

// Reference frame is after the last keyframe, so just use the last keyframe

// Reference frame is earlier than the first keyframe, so just use the first keyframe

// Regards the first three elements in propertyList as id, attrName, and attrType

// Regards this node as NULL-record if endOffset is zero

// Register color-packing define statements.

// ReinhardToneMapping;

// Remove from the events pool

// Remove from unordered set

// Render bokeh composite

// Render depth into texture

// Render input to screen

// Render targets

// Render targets containing layers, i.e: Texture 3D and 2d arrays

// Rendering

// Reset position and scale to original state

// Reset the buffer update indices.

// Reset the particle

// Reset the reference to the attribute's typed array

// Reset transfrom every 50ish navigations in one direction.

// Resize slides only after opener animation is finished

// Resolve Includes

// Restore background opacity

// Restore renderer settings

// Restore zoom level

// Return if the ray never intersects the plane

// Return the exports of the module

// Returns a unit vector tangent at t

// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order

// Root Container

// Rotate the emitter around it's central point

// Rotate the point about the center of the ellipse.

// Rotations are defined as Euler angles which can have values  of any size

// Rounding prevents precision errors of bilinear filtering:

// SAMPLER_2D

// SAMPLER_2D_ARRAY

// SAMPLER_2D_ARRAY_SHADOW

// SAMPLER_2D_SHADOW

// SAMPLER_3D

// SAMPLER_CUBE

// SAMPLER_CUBE_SHADOW

// SAMPLER_EXTERNAL_OES

// SETUP TNB variables

// SMAAArea below needs a sqrt, as the areas texture is compressed

// Safari 12 does not support PointerEvents API

// Safari can not handle Data URIs through XMLHttpRequest so process manually

// Safari occasionally does not emit transitionend event

// Safeguards if bevels are not enabled

// Save the starting value, but only once.

// Saves calculations being done and then overwritten in the shaders.

// Scale behind envMap

// Sean McCullough banksean@gmail.com

// See #14839

// See SPE.ShaderAttribute for a bit more info on this bit.

// See: https://twitter.com/FMS_Cat/status/1106508958640988161

// Serialization (in static context, because of constructor invocation

// Set GL state for depth map.

// Set PointSize according to size at current point in time.

// Set position on sphere

// Set properties used in the uniforms map, starting with the

// Set properties used to define the ShaderMaterial's appearance.

// Set the values in the typed array.

// Set up GL resources for the render target

// Setup GL resources for a non-texture depth buffer

// Setup color buffer

// Setup depth and stencil buffers

// Setup framebuffer

// Setup resources for a Depth Texture for a FBO (needs an extension)

// Setup storage for internal depth/stencil buffers and bind to correct framebuffer

// Setup storage for target texture and bind it to correct framebuffer

// Sides faces

// Simon Tatham's linked list merge sort algorithm

// Since js version 81, dynamic count calculation was removed

// Since materials are stored as indices, there's a bit of a mismatch between FBX and what

// Since we have 1 point left, we need to reinitiate drag

// Single float vector (from flat array or THREE.VectorN)

// Single matrix (from flat array or MatrixN)

// Single scalar

// Single texture (2D / Cube)

// Skew the input space to determine which simplex cell we're in

// Skip the Slerp for tiny steps to avoid numeric problems:

// Skip this track if it's non-numeric

// Slerp to the intermediate result

// Slide appended to DOM

// Slide in the 2nd holder is always active

// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,

// Some browsers do not composite the image until it's actually visible,

// Some browsers return HTTP Status 0 when using non-http protocol

// Some experimental-webgl implementations do not have getShaderPrecisionFormat

// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

// Some versions of I.E. have different rules for clearTimeout vs setTimeout

// Spot

// Spritesheets overwrite angle calculations.

// Start loading only after width is defined, as sizes might depend on it.

// State & Scheduling

// Static interface

// Stop the animation if velocity is low and position is close to end

// Store cumulative total face weights in an array, where weight index

// Store result in intermediate buffer offset

// Subtract each value for all other numeric track types

// Subtract the reference value from all of the track values

// Sum up and scale the result to cover the range [-1,1]

// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath

// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src

// TODO (abelnation): set RectAreaLight shadow uniforms

// TODO Attribute may not be available on context restore

// TODO Deprecate

// TODO consider referencing vectors instead of copying?

// TODO find a way to disable e.preventDefault on some elements

// TODO lengthSquared?

// TODO1 - have a .isClosed in spline?

// TODO:

// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600

// TODO: Better way to apply this offset?

// TODO: Copied from Object3D.toJSON

// TODO: Many values are identical up to roundoff error, but won't be optimised

// TODO: Move this bit to Light.fromJSON();

// TODO: Move to THREE.Image

// TODO: Reconsider this.

// TODO: add morph normal support

// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?

// TODO: height on mobile is very incosistent due to toolbar

// TODO: safely handle 64-bit integer

// TODO: this is not correct - FBX calculates outer and inner angle in degrees

// TODO: this should point to a unique id for this instance

// TODO? repeat nested values? And yoyo? And array values?

// TODO? restore this, then update the 07_dynamic_to example to set fox

// Tap can not trigger after drag

// Tap or double tap should not trigger if more than one pointer

// Target cannot move outside of this box

// Template methods for derived classes:

// Texture unit allocation

// The blender exporter exports diffuse here instead of in materialNode.Diffuse

// The blender exporter exports emissive color here instead of in materialNode.Emissive

// The blender exporter exports specular color here instead of in materialNode.Specular

// The current particle index for which particles should

// The end of the range in the attribute buffers

// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are

// The first three data sizes depends on version.

// The following properties are set internally and are not

// The integer offsets for the fourth simplex corner

// The module cache

// The number 1 in the "simplex" array is at the second smallest coordinate.

// The number 2 in the "simplex" array is at the second largest coordinate.

// The number 3 in the "simplex" array is at the position of the largest coordinate.

// The offset in the typed arrays this emitter's

// The original THREE.OrbitControls assume 60 FPS fixed and does NOT rely on delta time.

// The ray and segment are not parallel.

// The require function

// The result is scaled to return values in the interval [-1,1].

// The result is scaled to stay just inside [-1,1]

// The searches are bias by 1, so adjust the coords accordingly:

// The targeted u distance value to get

// The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"

// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'

// The transform of this joint will be updated with the joint pose on each frame

// Then discard if there is no edge:

// Then we go in the direction that has the maximum weight:

// There is only one item (which is the gallery)

// There's a possibility that this method returns wrong value if the value

// These contain details such as UV scaling, cropping, rotation etc and are connected

// These images are connected to textures in FBXTree.Objects.Textures

// These lines also handle the case where tmin or tmax is NaN

// These viewports map a cube-map onto a 2D texture with the

// These will be converted to quaternions which don't support values greater than

// This allows us to switch between absolute morphs and relative morphs without changing shader code

// This can potentially have a divide by zero if the box

// This helps with performance, specifically in iOS15 Safari.

// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

// This method does not support objects having non-uniformly-scaled parent(s)

// This should not cause noticable lag.

// This will force recalculation of size on next resize()

// Time Scale Control

// To ensure smooth animation

// To get accurate point with reference to

// To remove the need for index wrapping, double the permutation table length

// To think about boundaries points.

// To to emulate the speed of the original one under 60 FPS, multiply `60` to delta,

// Top and bottom faces

// Top bar is default position

// Top faces

// Total amount of cached images

// Touch Event

// Translate to the base position.

// Trigger click instead of tap for mouse events

// Try to calculate velocity,

// Try to find the current pointer in ongoing pointers by its ID

// Tweens are updated in "batches". If you add a new tween during an

// UINT

// UNSIGNED_INT_SAMPLER_2D

// UNSIGNED_INT_SAMPLER_2D_ARRAY

// UNSIGNED_INT_SAMPLER_3D

// UNSIGNED_INT_SAMPLER_CUBE

// Undo last step

// Unless there is only one image,

// Unless you bind it previously.

// Unroll Loops

// Unsure if this is the correct method to handle this case.

// Up to 4 lines can be crossing a pixel (one through each edge). We

// Update once per frame

// Update the joints groups with the XRJoint poses

// Update used to set exact time. Returns "this" AnimationMixer object.

// Updating index buffer in VAO now. See WebGLBindingStates

// Updating index buffer in VAO now. See WebGLBindingStates.

// Use OffscreenCanvas when available. Specially needed in web workers

// Use decode() on nearby slides

// Use initial bounds if defined

// Use initial zoom level

// Use the regular mix function and for additive on these types,

// Use transform scale() to modify img placeholder size

// Used by periodic NURBS to remove hidden spans

// Used internally by the TextParser

// Used when an emitter is removed.

// Users can still set in DataTexture3D directly.

// Using timeout hack to make sure that animation

// ValueBufferType is inherited

// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.

// Variables initialization

// Vector4

// Virtual base class method to overwrite and implement in subclasses

// WARNING: this discards revolution information -bhouston

// Wait for next browser tick like standard XMLHttpRequest event dispatching does

// Wait till all promises resolve and open PhotoSwipe

// We are within pan bounds, so just pan

// We assume images for cube map have the same size.

// We cannot overwrite getLengths() because UtoT mapping uses it.

// We cannot use the default THREE.Curve getPoint() with getLength() because in

// We clamp opacity to keep it between 0 and 1.

// We compute the minimum and maximum dot product values. If those values

// We correct the previous (-0.25, -0.125) offset we applied:

// We do a scale and bias for mapping to texel space:

// We do not call preventDefault for touch events

// We do not do this in Safari due to partial loading bug.

// We do the usual threshold:

// We need to know dimensions of the image to preload it,

// We track this so that the nested render call gets its list and state isolated from the parent render call.

// We use a thresholding to set the coordinates in turn from the largest magnitude.

// We use cache values if curves and cache array are same length

// We want the distances to be in pixel units (doing this here allow to

// We want the distances to be in pixel units:

// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):

// We're going to add .setXXX() methods for setting properties later.

// WebGL 2

// WebGL port note: Added

// WebGL port note: Added gamma correction

// WebGL port note: Changed sign

// WebGL port note: Changed sign in W component

// WebGL port note: Changed sign in Y and W components

// WebGL port note: Changed while to for

// WebGL2 formats.

// Weight

// What do we want? intersection point on the ray or on the segment??

// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)

// When binding events to lightbox,

// When object doesn't have morph target influences defined, we treat it as a 0-length array

// When pointer lock is enabled clientX, clientY, screenX, and screenY remain 0.

// When rendered geometry doesn't include these attributes but the material does,

// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally

// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally

// Where emitter's go to curl up in a warm blanket and live

// Whether all attributes should be forced to updated

// Why CubeTexture._needsFlipEnvMap is necessary:

// With delay, as image might be loaded, but not rendered

// Write values

// X - Positive x direction

// Y - Positive y direction

// You might ask "why dont you just decode() and then append all images",

// Z - Positive z direction

// Zero out time attribute for AnimationMixer object;

// Zero out time attribute for all associated AnimationAction objects.

// ZeroCurvatureEnding

// [  active actions  | inactive actions ]

// [  active actions >| inactive actions ]

// [ active actions |  inactive actions  ]

// [ active actions |< inactive actions  ]

// ["Lcl Scaling", "Lcl Scaling", "", "A", "1,1,1" ]

// _MAT2

// _MAT3

// _MAT4

// _VEC2

// _VEC3

// _VEC4

// __webpack_public_path__

// _containerShiftIndex*viewportSize will give you amount of transform of the current slide

// _getZeroBounds

// _gl.finish();

// _i.exhibitionScroll_rect.height

// _stopAllAnimations

// _t.Shaders.autoCreate(section.bubbleMat, 'Bubble'+section.path); 

// a morph geometry node is similar to a standard  node, and the node is also contained

// a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where

// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where

// a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and

// a subnode

// a top node

// access a sub element of the property array (only primitives are supported right now)

// according to the contained objects in the group

// accounting for both the object's, and children's, world transforms

// accounting is done, now do the same for all bindings

// accuN := accuN + additive accuN

// accuN := accuN + incoming * weight

// accuN := accuN + original * ( 1 - cumulativeWeight )

// accuN := incoming * weight

// accu[0..1] := orig -- initially detect changes against the original

// accumulate data in the 'incoming' region into 'accu<i>'

// accumulate data in the 'incoming' region into 'add'

// activate the new slide if it's current

// actual test, basically see if either of the most extreme of the triangle points intersects r

// add '.0' if integer

// add := add + incoming * weight

// add = identity

// add a group to the geometry. this will ensure multi material support

// add classes to the root element of PhotoSwipe

// add image to slide when it becomes active,

// add new pointer

// add padding

// additive is not relevant for non-numeric types

// adds object as a child of this, while maintaining the object's world transform

// advance the time and update apply the animation

// after end

// algorithm thanks to Real-Time Collision Detection by Christer Ericson,

// all vertices should lie on a conceptual sphere with a given radius

// allocate all resources required to run it

// allow developers to perform some task before opening

// allow filtering

// allow single and array values for "shapes" parameter

// allow straightforward parsing of the hierarchy that WebGL encodes

// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!

// also bind events to PhotoSwipe Core,

// also part of uniforms common

// also, take the clip from the prototype action

// although .enabled = false yields an effective weight of zero, this

// although .paused = true yields an effective time scale of zero, this

// although must now be relative to the new union camera.

// always preventDefault move event

// always update environment and fog - changing these trigger an initMaterial call, but it's possible that the program doesn't change

// an effective weight of 0

// and BinaryParser( FBX Binary format)

// and a special attribute Index defining which vertices of the original geometry are affected

// and automatic invocation of .toJSON):

// and convert the integer string to a true integer.

// and details the connection type

// and don't re-calculate size on inital size update

// and in the direction of the minimum tangent xyz component

// and is referenced by an AnimationLayer

// and kill off any particles whose age is over the limit.

// and make the action known to the memory manager

// and no shorter than 50ms

// and only call .getValue on the first

// and remove duplicates

// and return as array

// and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)

// and this way their names minify.

// and we do not need browser to scroll the page

// and we do not want to bounce opacity.

// and you don't preventDefault touchstart (which PhotoSwipe does),

// angles are in radians

// animation value as well

// aperture - bigger values for shallower depth of field

// appears to be still using it -> rebind

// append our three slide holders -

// append to DOM

// apply the state of 'accu<i>' to the binding when accus differ

// apply the state previously taken via 'saveOriginalState' to the binding

// apply time scale and advance time

// appropriate state

// approximate tangent vectors via finite differences

// arbitrary location outside of triangle?

// are on the same side (back or front) of the plane, then there is no intersection.

// aria pattern: carousel

// array[ i ] = 0;

// arrowNextSVG

// arrowPrevSVG

// as animating opacity is faster than animating rgba()

// as browser can render parts of image while it is loading.

// as each axis has own pan boundaries and thus different spring function

// as if srcset sizes changes dynamically - it may cause decode error

// as it might use srcset and we need to define sizes

// as rendering (even small stretched thumbnail) is an expensive operation

// as we have reached here there are no singularities so we can handle normally

// as well as when this slide is not active

// assign slide to content

// assigning data to HTMLImageElement.src is asynchronous (see #15162)

// assume single camera setup (AR)

// assumes axis is normalized

// assumes min < max, componentwise

// assumes q is normalized

// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

// assumes: opposite

// assuming Uint8Array

// assuming for LoopOnce atStart == atEnd == true

// attributes

// auto-setting of texture unit for bone texture must go before other textures

// automatic length determination in AnimationClip.

// avoid artifacts caused by neighbour fragments with minimal depth difference

// avoid the influence of fragments which are too far away

// axis ( e.g. times and values of x rotation)

// axis is assumed to be normalized

// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)

// azimuthal angle

// b1 < 0, no intersection

// b1+b2 > 1, no intersection

// b2 < 0, no intersection

// back to the prototype version of getValue / setValue

// backwards compatibility

// band 0

// band 1

// band 2

// bare name or "pure" bottom-level array "[0]" suffix

// barycentric coordinates must always sum to 1

// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm

// based on http://www.terathon.com/code/tangent.html

// based on: http://www.blackpawn.com/texts/pointinpoly/default.html

// basically, we're distinguishing which of the voronoi regions of the triangle

// be marked as active on the next update cycle.

// beauty render target

// before start

// being serialized.

// better interleave arithmetic and memory accesses):

// bevels not supported for path extrusion

// bezierCurveTo

// binary search

// binary search for the index with largest value smaller than target u distance

// bind all binding

// blur material

// bokeh material

// bottom

// bottom row

// bound by the mixer

// bounding box

// bounding sphere

// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

// browser image drag feature

// browsers aren't good at changing the direction of the CSS transition

// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]

// buffers

// build each side of the box geometry

// build geometry

// build non-indexed geometry

// but newer versions of browsers now support PointerEvent.

// but no longer than 250ms,

// but ours are more flexible to any FPS unlike the original.

// by default click zooms current image,

// by default it's displayed only for the first slide

// by default, we assume the data can be serialized as-is

// c = (3-sqrt(3))/6

// c = 1/6.

// cacheLengths must be recalculated.

// cached from whatever global is present so that test runners that stub it

// cached objects followed by the active ones

// cached or active

// calculate area of the contour polygon

// calculate delta of the last touchmove tick

// calculate inverse bone matrices if necessary

// calculate negative value

// calculate new start value for groups

// calculate result * inverse quat

// calculate sample point

// calculate the world matrix for each instance

// call ._updateWeight() to update ._effectiveWeight

// called by the mixer

// camera matrices cache

// can't generate mipmaps for compressed textures

// cancel will be overwritten in the constructor.

// case where there are multiple materials but the whole geometry is only

// cast values where needed, otherwise leave as strings

// caught by singularity test above, but I've left it in just in case

// causes forced synchronous layout

// center coords of 2 finger truck

// changed glsl or parameters

// changed main scroll

// changes

// check boundary cases, again

// check cube texture with data textures

// check direction of vertices

// check first triangle

// check for link errors

// check for scheduled start of action

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)

// check if a point lies within a convex triangle

// check if a polygon diagonal intersects any polygon segments

// check if a polygon diagonal is locally inside the polygon

// check if it's necessary to rebuild cameraVR's camera list

// check if pointer was shifted horizontally or vertically

// check if the current tap is close to the previous one,

// check if the middle point of a polygon diagonal is inside the polygon

// check if the ray lies on the plane first

// check if this node represents just a single property

// check if two points are equal

// check if two segments intersect

// check second triangle

// check that the curves are defined for at least one axis, otherwise ignore the curveNode

// check whether a polygon node forms a valid ear with adjacent nodes

// checkPanBounds

// checked by the renderer

// checking the type.

// clamp for floating pt errors

// clamp, to handle numerical problems

// clean up public variables

// clear all points on mouseup

// clearing

// clearly, this should be optimised to

// clip must be known when specified via string

// clipping

// closeSVG

// collinear or singular triangle

// collision detection

// collisionTest uses nearPlane.s

// color keywords

// combine data linearly

// common matrices

// compressed cubemap texture stored in a single DDS file

// compute box center and extents

// compute edge vectors for triangle

// compute euclidian modulo of m % n

// compute linear depth of the sample view Z value

// compute matrix used to reorient a kernel vector

// compute position in camera space

// compute tangents when parameterized in [t1,t2]

// compute the local matrices, positions, rotations and scales

// compute the offset between the current and the original transform

// compute the slowly-varying normal and binormal vectors for each segment on the curve

// compute the tangent vectors for each segment on the curve

// compute uv coordinates

// computes for inPt the corresponding point inPt' on a new contour

// configs

// connect the stacks (clips) up to the layers

// connections

// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

// console.log( 'THREE.Cache', 'Adding key:', key );

// console.log( 'THREE.Cache', 'Checking key:', key );

// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

// console.log( 'flagUpdate:', range.offset, range.count );

// console.log( fbxTree );

// console.log( range.offset, range.count, this.typedArray.array.length );

// console.log("Holes first", holesFirst);

// console.log("Warning: lines are a straight sequence");

// console.log("Warning: lines are a straight spike");

// console.log("ambiguous: ", ambiguous);

// console.log("to change: ", toChange);

// console.log('i,j,k', i, j , k)

// console.log(event,target);

// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

// construct all of the faces

// construct all of the vertices for this subdivision

// continue;

// continue;				// no intersection or edgeLowPt => doesn't count !!!

// contract shape

// convert string to array, unless it ends in ',' in which case more will be added to it

// convert to "pixels per second"

// convert to integer

// converts an array to a specific type

// coords are transformed into non-negative 15-bit integer range

// copies a sample value to the result buffer

// copy current values

// copy material

// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,

// corner at max distance

// corresponds to face index.

// counters

// create a PerspectiveCamera or OrthographicCamera

// create a circular doubly linked list from polygon points in the specified winding order

// create a fake namespace object

// create a node and optionally link it with previous one (in a circular doubly linked list)

// create a track for each morph target with all zero

// create button element

// create color only once here, reuse it later inside the render function

// create content if not found in cache

// create getter / setter pair for a property in the scene graph

// create the main Group() to be returned by the loader

// cross product of tangent vectors returns surface normal

// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

// cube textures can't reuse the same canvas

// currently no opt-out).

// custom blending

// cut off the triangle

// cycle.

// dataSource has gallery property,

// deactivates all previously scheduled actions

// decompose spherical to the camera position

// decrement reference counts / sort out state

// default buffer data

// default for when object is not specified

// default order is 0

// define __esModule on exports

// define getter function for harmony exports

// define options for PhotoSwipe constructor

// defined by v0 and v1

// deinterleave data and save it as an ordinary buffer attribute for now

// deltaTime value is in seconds

// dependencies

// dependency on THREE r81+.

// deprecated options

// depth material

// derived classes can define a static parse method

// derived classes can define a static toJSON method

// destroy previous slide

// detaches the buffer when complete, preventing reuse.

// determine how the property gets bound

// determine versioning scheme

// diffuse

// dipsose full screen quad

// direction is assumed to be normalized (for accurate distance calculations)

// direction:

// directoryName: matches[ 1 ], // (tschw) currently unused

// disable pan to next slide for non-touch devices

// disable zoom

// discern what value each edge has:

// displacement is like distance, but can be negative.

// display loading indicator with delay

// dispose materials

// dispose render targets

// divide by *height* to refer the resolution

// divide by distance to normalize, lighter than `Vector3.prototype.normalize()`

// do blur pass for VSM

// do not animate opacity if it's already at 0

// document.documentElement.clientHeight - doesn't seem to work well

// does not create opposite-facing sectors

// don't break things.  But we need to wrap it in a try catch in case it is

// don't create geometry if it is not associated with any models

// don't update color or depth

// done to make examples/js code work. Normally, FullScreenQuad should be exported

// dones't intersect other edges

// drag is activated only after the axis is determined

// draw if == 1

// draw into the stencil buffer

// draw range

// duplicate the bone here and and it as a child of the first bone

// e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +

// e.g. 'file://' or 'data://'. Handle as success.

// e.g. position times: [0, 0.4, 0. 8]

// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )

// edge lies on the same horizontal line as inPt

// edge region of AB; barycentric coords (1-v, v, 0)

// edge region of AC; barycentric coords (1-w, 0, w)

// edge region of BC

// edge region of BC; barycentric coords (0, 1-w, w)

// element outside of top bar gets a secondary class

// elements that overlap it (such as icons over the thumbnail)

// eliminate colinear or duplicate points

// else if ( value < 0 && value > -epsilon ) {

// else if ( value > 0 && value < epsilon ) {

// else the object is already where we want it to be

// emissive

// empty

// empty keys are filtered out, so check again

// empty string to avoid regexp issues

// empty tracks are forbidden, so keep at least one keyframe

// enable code injection for non-built-in material

// enable mouse features if no touch support detected

// enable state of previous frame - the clipping code has to

// enables MultiMaterial support

// ensure Vector4 for control points

// ensure _progress does not exceed duration with looped audios

// ensure that element exists and is not already appended

// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.

// ensure there is a value node

// ensure unique state

// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable

// ensures no consecutive points are duplicates

// ensures that deltaAngle is 0 .. 2 PI

// entering the last round

// entire path distance at time t,

// equivalent to ( x * -1 ) - 1

// error response bodies as proper responses to requests.

// esc

// eslint-disable-line

// eslint-disable-line no-undef

// eslint-disable-next-line

// eslint-disable-next-line @typescript-eslint/no-unused-vars

// eslint-disable-next-line class-methods-use-this

// eslint-disable-next-line max-len

// eslint-disable-next-line no-undef

// evaluate polynomials

// evaluate the basis functions

// even if it's not finished decoding

// even if the `update()` method was called way past the duration of the tween

// even though preventDefault IS called on mousemove. That's why we preventDefault mousedown.

// event listeners must be registered before WebGL context is created, see #12753

// existing binding, make sure the cache knows

// exit if holder already contains this slide

// exit if no loop and index is out of bounds

// expand holes

// expose the method

// expose the module cache

// expose the modules object (__webpack_modules__)

// extract data from the cache hash

// extract local rotation of light to derive width/height half vectors

// extracts

// extracts the data from the correct position in the FBX array based on indexing type

// extrapolate first point

// extrapolate last point

// eye and target are in the same position

// f''(t0) = 0 a.k.a. Natural Spline

// f''(tN) = 0, a.k.a. Natural Spline

// f'(t0) = 0

// f'(tN) = 0

// face region

// faces

// faces one and two

// fade out background if zooming out

// faded out, disable

// fall back to default, unless the default itself is messed up

// falling back to the defaultValue if any aren't.

// false -> zero effective weight

// fatal, in this case

// favor blending by choosing the line with the maximum weight for each

// figure out all morph targets used in this track

// fill image into the area

// film not completely covered in landscape format (aspect > 1)

// film not completely covered in portrait format (aspect < 1)

// filter colinear points around the cuts

// filter collinear points around the cuts

// filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to

// final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

// finally testing the face normal of the triangle

// finally, create the uv data

// find a bridge between vertices that connects hole with an outer ring and and link it

// find a segment intersected by a ray from the hole's leftmost point to the left;

// find a way to improve this

// find minimum .times value across all tracks in the trimmed clip

// find the center

// find the leftmost node of a polygon ring

// find the radius

// first Connection is FBX type (OO, OP, etc.). We'll discard these

// first check for identity matrix which must have +1 for all terms

// first join together the times for each axis, if defined

// first, find the center of the bounding sphere

// flag that it needs updating on the next render

// flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]

// flatten bone matrices to array

// flip the tween direction back to forward.

// float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);

// flush last keyframe (compaction looks ahead)

// focus causes layout,

// focus root element

// following has to be done:

// following orientation:

// footer size: 160bytes + 16-byte alignment padding

// for (const prop in properties) this._valuesEnd[prop] = properties[prop]

// for arguments

// for backward compatability if shading is set in the constructor

// for backward compatibility on non-VAO support browser

// for backward-compatilibity

// for backwards compatibility

// for bookkeeping

// for both PerspectiveCamera and OrthographicCamera

// for collinear points p, q, r, check if point q lies on segment pr

// for conforming with the other functions we've written for other data.

// for easier access.

// for now do nothing,

// for objects that are cached, the binding may

// for old three.js, which supports both BufferGeometry and Geometry

// for physically correct lights, should be 2.

// for quicker access.

// for smooth interpolation w/o separate

// for some reason)

// for special case: base64 image data follows "Content: ," line

// for the memory manager

// forget previous loops

// forget scheduling

// free all resources specific to a particular clip

// free all resources specific to a particular root target object

// free resource

// from global to local

// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h

// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

// from this module like Pass.

// frustum

// function because try/catches deoptimize in certain engines.

// function for parsing AOS keyframe formats

// functions

// fuzz-free, array-based Quaternion SLERP operation

// gallery and children options

// general case

// generate UUID for array buffer if necessary

// generate indices

// generate transformation from FBX transform data

// generate vertices, normals and uvs

// get a texture from the textureMap for use by a material.

// get an existing action

// get geometry and materials(s) from connections

// get linear depth from depth texture

// get points of shape and holes (keypoints based on segments parameter)

// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal

// get the radiance in the direction of the normal

// get the vertices of the face

// getDefaultExport function for compatibility with non-harmony modules

// getPoint() depends on getLength

// gets clamped or wrapped to 0..clip.duration according to loop

// gl.detachShader( program, glFragmentShader );

// gl.detachShader( program, glVertexShader );

// global mixer time when the action is to be started

// go forward

// go through all polygon nodes and cure small local self-intersections

// good reading for geometry algorithms (here: line-line intersection)

// grid

// groups

// h,s,l ranges are in 0.0 - 1.0

// half of the fov is center to top of screen

// handle an array of relative values

// handle case if texture exceeds max size

// handle case when face straddles the seam, see #3269

// handle special case

// handle special case of collinear edges

// handle the deepness of the values

// has a size dimension of 0.

// have to stop (switch state, clamp time, fire event)

// helix

// helper functions

// helper variables

// hex color

// hide nearby item holders until initial zoom animation finishes (to avoid extra Paints)

// hide nearby slides to make sure that

// hide placeholder to allow hiding of

// hierarchy. Each Stack node will be used to create a AnimationClip

// hole touches outer segment; pick leftmost endpoint

// horizontal angle

// horizontal film offset (same unit as gauge)

// horizontal pass

// horizontal vs. vertical

// hsl(120,50%,50%) hsla(120,50%,50%,0.5)

// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a

// http://en.wikipedia.org/wiki/Smoothstep

// http://geomalgorithms.com/a05-_intersect-1.html

// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf

// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html

// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

// http://www.mathworks.com/matlabcentral/fileexchange/

// http://www.quirksmode.org/js/events_properties.html

// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/

// https://bugs.webkit.org/show_bug.cgi?id=170595

// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener#matching_event_listeners_for_removal

// https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent

// https://developer.mozilla.org/en-US/docs/Web/API/event.button

// https://drafts.csswg.org/css-transitions/#starting

// https://en.wikipedia.org/wiki/Damping_ratio

// https://en.wikipedia.org/wiki/Linear_interpolation

// https://en.wikipedia.org/wiki/Modulo_operation

// https://en.wikipedia.org/wiki/Natural_frequency

// https://en.wikipedia.org/wiki/Oscillation

// https://graphics.stanford.edu/papers/envmap/envmap.pdf

// https://hackernoon.com/onresize-event-broken-in-mobile-safari-d8469027bf4d

// https://stackoverflow.com/a/44849975

// https://taye.me/blog/tips/2015/11/16/mouse-drag-outside-iframe/

// https://www.desmos.com/calculator/vcsjnyz7x4

// if ( params[ index ] !== 0.0 && ( this.particleCount !== 1 || this.activeMultiplier !== 1 ) ) {

// if ( parseFloat( REVISION ) >= 81 ) {

// if ( value === 0 ) {

// if (!centerPoint) {

// if (transitionDuration === undefined) {

// if PhotoSwipe is opening or closing

// if a previous curve is present, attempt to join

// if all the models where already combined in a single group, just return that

// if clearTimeout wasn't available but was latter defined

// if content can be loaded, add it to cache:

// if content is reloaded

// if difference between slides is more than 1

// if element propery was modified during the transition,

// if fragment is before sample point, increase occlusion

// if it can not be zoomed - gallery will be closed

// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,

// if it wasn't calculated yet in drag.change

// if it's empty link href is used

// if it's open.

// if left/right/top/bottom key

// if main scroll position is shifted – direction is always horizontal

// if not open yet - check against initial zoom level

// if object is known

// if one belongs to the outer ring and another to a hole, it merges it into a single ring

// if resolution is not defined (user didn't zoom yet)

// if set to true, the pass clears its buffer before rendering

// if set to true, the pass indicates to swap read and write buffer after rendering

// if set to true, the pass is processed by the composer

// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.

// if setTimeout wasn't available but was latter defined

// if the animated model is pre rotated, we'll have to apply the pre rotations to every

// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

// if the line doesn't end in ',' we have reached the end of the property value

// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

// if the subnode already exists, append it

// if the texture is a layered texture, just use the first layer and issue a warning

// if the weight array is shorter than 4 pad with 0s

// if there are no manual mipmaps

// if there are no points found, we have a valid connection;

// if there is a key at the first frame, duplicate it as the

// if there is an x value defined for this frame, use that

// if there is more than one model associated with the geometry this may cause problems

// if this is encountered the line needs to be joined to the previous line

// if this is undefined we can safely assume there are no animations

// if we close during opening animation

// if we looped through the whole remaining polygon and can't find any more ears

// if we walk along contour clockwise, this new contour is outside the old one

// if yes - trigger double tap

// image not yet ready. try the conversion next frame

// implementations shall return this.resultBuffer

// impossible. Only the 24 indices which have non-zero entries make any sense.

// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal

// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,

// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

// in case device supports both touch and mouse events,

// in leading diagonal and zero in other terms

// in order to always return an intersect point that is in front of the ray.

// in the constructor

// in the uniform names.

// in this case we need a unique material instance reflecting the

// in-place compaction

// in: 'cubic-bezier(.4, 0, 1, 1)'// for "hide" transitions

// inOut: 'cubic-bezier(.4, 0, .22, 1)', // for "toggle state" transitions

// inPt is on contour ?

// inPt on polygon contour => immediate success    or

// inPt' is the intersection of the two lines parallel to the two

// inPt: Point on contour !

// incides

// include '.' characters).

// inclusive -> exclusive bound

// increase counter

// increment reference counts / sort out state

// index

// indexed buffer geometry

// indexed elements

// indicates whether this is a steiner point

// indices

// init

// init Centripetal / Chordal Catmull-Rom

// initial state of these methods that calls 'bind'

// initialise list

// initialize

// initialize meta obj

// initialize scroll wheel handler to block the scroll

// inject array a2 into array a1 at index

// input: THREE.Matrix4 affine matrix

// inside:

// inside: Array< PropertyBinding >

// inside: Map< name, PropertyMixer >

// inside: PropertyMixer (managed by the mixer)

// inside: indices in these arrays

// inside: string

// inside: { we don't care, here }

// intensity = power per solid angle.

// interlink polygon nodes in z-order

// internal properties

// internal state cache

// interpolators can use .buffer as their .result

// into array like below

// invert time for the "pong round"

// is no way to parse 'foo.bar.baz': 'baz' must be a property, but

// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.

// isMainScrollRunning() {

// it and ensure all the values are of the correct type,

// it is independent from slide index

// it seems like stacks will always be associated with a single layer. But just in case there are files

// it'll be measured incorrectly in resize event

// it's a legacy verion before filters were introduced

// it's added to one.

// it's set back to 'null' upon start of the action

// iterate over all faces and apply a subdivison with the given detail value

// iterate over the entire buffer and apply the radius to each vertex

// iterate through ears, slicing them one by one

// iteration state and also require updating the state we can

// join vertices of inner and outer paths to a single array

// just started

// just throw away

// keep feeding the last frame?

// keep running

// large arrays are split over multiple lines terminated with a ',' character

// last cached object takes this object's place

// last column

// last frame as well for perfect loop.

// last object goes to the activated slot and pop

// lateUpdate

// layout (1 matrix = 4 pixels)

// left

// left bottom back corner

// left bottom front corner

// left top back corner

// left top front corner

// left vs. right

// left/right arrow keys pan horizontally.

// legacy

// legacy event

// legacy event, before filters were introduced

// legacy option

// length of vectors for normalizing

// less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

// let 'undefined' and 'null' pass

// let item;

// let itemIndex;

// light disabled

// lighting uniforms depend on the camera so enforce an update

// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}

// line is coplanar, return origin

// lineTo

// linear reverse scan

// linear scan

// link every hole into the outer loop, producing a single-ring polygon without holes

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;

// load a texture specified as a blob or data URI, or via an external URL using TextureLoader

// load material specific uniforms

// locally visible

// lock buffers

// look for a valid diagonal that divides the polygon into two

// look for points inside the triangle in both directions

// look for points inside the triangle of hole point, segment intersection and endpoint;

// look for remaining points in decreasing z-order

// look for remaining points in increasing z-order

// loop over the bone's vertex indices and weights

// loop where sum != 0, sum > d , sum+1 <d

// looping?

// luminosity high pass material

// m11 is the largest diagonal term

// m22 is the largest diagonal term

// m33 is the largest diagonal term so base result on this

// main ear slicing loop which triangulates a polygon (given as a linked list)

// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation

// make oriented bounding box

// make sure that pointer moved since the last update

// mandatory

// map listeners from Lightbox to PhotoSwipe Core

// maps to F0 = 0.04

// margin to distinguish between 0 and 180 degrees

// mark the emitter as dead.

// material

// material for rendering the content of a render target

// material for rendering the depth

// materials - pass 1

// materials - pass 2

// materials - pass 3

// max blur amount

// max zoom level is x4 from "fit state",

// maximum pan position

// may be an array or just object with length property

// merges multi-byte utf-8 characters.

// meta is a hash used to collect geometries, materials.

// meta is a string when called from JSON.stringify

// method assumes no rotated parent

// method does *not* change .enabled, because it would be confusing

// method does *not* change .paused, because it would be confusing

// minX, minY and invSize are later used to transform coords into integers for z-order calculation

// minimum pan position

// mips must be embedded in DDS files

// mix functions

// mode & 1: value is a module id, require it

// mode & 2: merge all properties of value into the ns

// mode & 4: return value when already ns object

// mode & 8|1: behave like require

// module.parent = undefined by default

// morph attributes

// morph targets

// morphAttribute: array of Float32BufferAttributes

// morphTargetInfluences except for the keys in which

// morphs

// most PhotoSwipe events call preventDefault,

// motion has halted, pause

// move all keyframes either forwards or backwards in time

// move existing object into the CACHED region

// move existing object to the ACTIVE region

// move first to last

// move last to first

// move to the end of array

// moveTo

// msrc is URL to placeholder image that's displayed before large image is loaded

// must use copy for Object3D.Euler/Quaternion

// name

// near plain half width

// negative X

// negative Y

// negative Z

// new material

// no cached content, so try to load from scratch:

// no data

// no flipping for cube textures

// no. of repetitions when looping

// node transform

// non-indexed buffer geometry

// non-indexed elements (unconnected triangle soup)

// normal

// normal is assumed to be normalized

// normal is assumed to be unit length

// normal is assumed to have unit length

// normal material

// normal render target with depth buffer

// not collinear

// not parallel

// not providing it implies that this is the root object

// not sure if this is the best idea, maybe should be returning undefined

// note: _updateTime may disable the action resulting in

// note: all lighting uniforms are always set correctly

// note: always updating when .needsUpdate is undefined

// note: avoiding to mutate the shape of 'this' via 'delete'

// note: happily accumulating nothing when weight = 0, the caller knows

// note: just calling _removeInactiveAction would mess up the

// note: read by PropertyBinding.Composite

// note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead

// note: same logic as when updated at runtime

// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack

// nothing to animate

// notice: z-offset will not affect in Orthographic.

// now apply vector to normal buffer

// now apply vector to vertex buffer

// now make sure we don't have other points inside the potential ear

// now, in case this material supports lights - or later, when

// null

// null will disable sheen bsdf

// number

// nx

// ny

// nz

// object (this method allocates a lot of dynamic memory in case a

// object instead of the material, once it becomes feasible

// object is active, just swap with the last and pop

// object is cached, shrink the CACHED region

// object specific properties

// offset[1].x = texcoord.x - 0.25 * resolution.x;

// offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)

// on iOS10 if you bind touchmove/end after touchstart,

// only Holes? -> probably all Shapes with wrong orientation

// only need to fire this at scroll start.

// only perform resize for certain image types

// only perform resize if necessary

// only rebuild uniform list

// only render where stencil is set to 1

// only return track if there are actually keys.

// only set detune when available

// optional, subclass-specific settings structure

// options

// or arrowKeys option is disabled

// or if speed it too low

// or if we are below and moving downwards

// or may not exist

// orthographic

// otherwise choose the point of the minimum angle with the ray as connection point

// otherwise push as-is

// otherwise textures used for skinning can take over texture units reserved for other material textures

// otherwise this singularity is angle = 180

// otherwise transitionend might not fire or transiton won't start.

// otherwise use the x value from the previous frame

// out their days.

// out: 'cubic-bezier(0, 0, .22, 1)', // for "show" transitions

// output result to screen

// override the renderer's default precision for this material

// p1, q1 and p2 are collinear and p2 lies on p1q1

// p1, q1 and q2 are collinear and q2 lies on p1q1

// pan

// pan according to the zoom level

// parallel

// parallel or collinear

// parameters, make sure they are correct for the dstTexture

// params: utils.ensureTypedArg( options.maxAge.randomise, types.BOOLEAN, !!options.maxAge.spread ) ||

// parent transform

// parentGeo.morphAttributes.normal = []; // not implemented

// parse "Property70"

// parse Geometry data from FBXTree and return map of BufferGeometries

// parse an FBX file in ASCII format

// parse animation data from FBXTree

// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to

// parse nodes in FBXTree.Objects.AnimationCurveNode

// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references

// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation

// parse nodes in FBXTree.Objects.Model

// parse the animation.hierarchy format

// parse the model node for transform data

// particle's values will start at

// particles.

// pass 1

// pass 2

// pass 3

// patterns like Walk_001, Walk_002, Run_001, Run_002

// perform subdivision

// physical lights

// physically based shading

// point behind the ray

// point objects are defined once and reused

// point: raycaster.ray.at( distance ),

// points of the projected triangle are outside the projected half-length of the aabb

// polar angle

// populate depth texture with dummy data

// position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]

// positive X

// positive Y

// positive Z

// potential future optimization: skip this if propertyIndex is already an integer

// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

// preload[0] - num items to preload in backward direction

// preload[1] - num items to preload in forward direction

// prepare binary search on the left side of the index

// prepare binary search on the right side of the index

// prevent divide by zero, should not happen if matrix is orthogonal and should be

// prevent page scroll

// preventDefault mouse event to prevent

// preventDefault will have no effect on touchmove and touchend.

// previous and next nodes in z-order

// previous and next vertex nodes in a polygon ring

// previous, current, and next

// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated

// previously unknown clip/root combination is specified)

// private interface

// process array of images e.g. CubeTexture

// process holes from left to right

// process morph attributes if present

// process morph targets

// process single image

// process the result of raycast

// programs with morphTargets displace position out of attribute 0

// project all 3 vertices of the triangle onto the seperating axis

// project point and calculate NDC

// project the aabb onto the seperating axis

// project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)

// properties transformations

// prototype, continued

// public properties

// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,

// purposefully using finally instead of then,

// push to the pre-sorted opaque render list

// px

// py

// pz

// q is assumed to be normalized

// quadraticCurveTo

// quadratically:

// quaternion is assumed to have unit length

// query DOM elements

// radians

// raw image data is in videoNode.Content

// raw property list used by parent

// ray origin is behind the plane (and is pointing behind it)

// readjust pan position if it's beyond the bounds

// ready to go again if required

// recover the bind-time world matrices

// recursively parse nodes until the end of the file is reached

// red

// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf

// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf

// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e

// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html

// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm

// reflect incident vector off plane orthogonal to normal

// reflex, can't be an ear

// refresh uniforms common to several materials

// region 0

// region 1

// region 2

// region 3

// region 4

// region 5

// regular Texture (image, video, canvas)

// relative to the image

// release the pointer - remove it from ongoing

// remember the state of the bound property and copy it to both accus

// remove & forget

// remove a targeted clip from the cache

// remove adjacent keyframes scheduled at the same time

// remove metadata on each item

// remove two nodes involved

// remove unnecessary keyframes same as their neighbors

// removes equivalent sequential keys as common in morph target sequences

// removes keyframes before and after animation without changing any values within the range [startTime, endTime].

// render SSAO

// render beauty

// render blur

// render depth map

// render normals and depth (honor only meshes, points and lines do not contribute to SSAO)

// render scene

// render targets

// render() can be called from within a callback triggered by another render.

// renderBufferDirect second parameter used to be fog (could be null)

// reorient sample vector in view space

// repetitive Repeat or PingPong

// replace all %d with size

// required

// rescale tangents for parametrization in [0,1]

// reset

// reset RegExp object, because of the early exit of a previous run

// reset arrays for the next face

// reset caching for this frame

// reset existing normals to zero

// reset internals

// reset state

// reset zoom level

// resolve multisample renderbuffers to a single-sample texture if necessary

// resolve property

// restart clip

// restore main scroll position

// restore original state

// restrict phi to be betwee EPS and PI-EPS

// resulting translation vector for inPt

// return 180 deg rotation

// return an action for a clip optionally using a custom root target

// return the time scale considering warping and .paused

// return the weight considering fading and .enabled

// return this mixer's root target object

// return true when play has been called

// return zoom level and its bounds to initial

// returns an array by which times and values can be sorted

// returns an array of bindings for the given path that is changed

// rgb / hsl

// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)

// rgb(255,0,0) rgba(255,0,0,0.5)

// right

// right bottom back corner

// right bottom front corner

// right top back corner

// right top front corner

// root DOM element of PhotoSwipe (.pswp)

// rotate geometry around world x-axis

// rotate geometry around world y-axis

// rotate geometry around world z-axis

// rotate object on axis in object space

// rotate object on axis in world space

// rotation

// rotation (SpriteMaterial)

// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'

// rotations are applied to the axes in the order specified by 'order'

// round to closest axis ( forward | backward | right | left | top | bottom )

// run active actions

// run another frame in order to reset the state:

// run earcut on each half

// safety check for repeated points

// same as Array.prototype.slice, but also works on typed arrays

// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error

// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.

// same game as above

// same glsl and uniform list

// same with filters

// sanitize index

// sanity check

// save as true interlaved attribtue

// save original state

// scale all keyframe times by a factor (useful for frame <-> seconds conversions)

// scale geometry

// scale the rotation part

// scaled local time of the action

// scene could be a Mesh, Line, Points, ...

// scene graph

// search into node subtree.

// search into skeleton bones.

// second, try to find a boundingSphere with a radius smaller than the

// see #10732

// see #16358

// see #17920

// see #18859

// see http://jacksondunstan.com/articles/983

// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

// see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#value

// see https://github.com/microsoft/TypeScript/issues/32912#issuecomment-522142969

// see https://github.com/yomotsu/camera-controls/issues/335

// seek

// seems like true/false representation depends on exporter.

// segment's endpoint with lesser x will be potential connection point

// segments

// select an initial normal vector perpendicular to the first tangent vector,

// select getter / setter

// set 0 level mipmap and then use GL to generate other mipmap levels

// set content for center slide (first time)

// set current slide

// set fail state so we can just 'return' on error

// set initial index

// set name and id here - otherwise in cases where "subBone" is created it will not have a name / id

// set offset after the orbit movement

// set origin in plane of camera

// set the new slide content

// set the time scale stopping any scheduled warping

// set the weight stopping any scheduled fading

// set to true on material change

// set to use derivatives

// set to use draw buffers

// set to use fragment depth values

// set to use morph normals

// set to use morph targets

// set to use scene fog

// set to use scene lights

// set to use skinning attribute streams

// set to use user-defined clipping planes

// set up caching for uniform locations

// set values to correct vector component

// set zoom level, so pan bounds are updated according to it

// setup pass state

// shBasis is an Array[ 9 ]

// shadow map

// shift all tracks such that clip begins at t=0

// shift the main scroller to zero position

// shim for using process in browser

// signed

// signed area of a triangle

// silently ignore degenerate uv triangles having coincident or colinear vertices

// simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.

// since it has probably changed.

// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,

// since we do not bother to create new bindings

// singularity found

// skinning uniforms must be set even if material didn't change

// skip empty tracks

// skip magic 23 bytes

// skipping the next vertex leads to less sliver triangles

// slide just became active

// slide just became non-active

// slightly over the zoom.fit

// so I need to do it manually here.

// so convert the string to an array

// so developer doesn't need to do this manually

// so it's not ideal way to detect them.

// so leave loopCount at -1

// so we do not pass the initialPoint

// so we store largest used size in dataset.

// sort by order

// sort morph target names into animation groups based

// special case Pose needs PoseNodes as an array

// special case for the poles

// special case: child node is single property

// special cases were we need to reach deeper into the hierarchy to get the face materials....

// special zero-length case

// sphere

// split the polygon in two by the diagonal

// split this

// sprite.scale.set(x,y)

// squared length of deltaClampedTarget

// src comes from data-pswp-src attribute,

// src/slide/content/content.js

// ssao material

// ssao render target

// standard BufferGeometry serialization

// standard Material serialization

// standard Object3D serialization

// start

// starting index can be modified here

// starts even if the animated property was changed recently,

// static/instance method to calculate barycentric coordinates

// steps + 1

// stop all pan and zoom transitions

// store the light setup it was created for

// strictly front facing

// subsequent uv buffers are called 'uv1', 'uv2', ...

// such flamingo_flyA_003, flamingo_run1_003, crdeath0059

// support legacy w & h properties

// support only transform and opacity

// support resolving morphTarget names into indices.

// t < 0, no intersection

// t0 = first intersect point - entrance on front of sphere

// tab

// table

// take raw animation clips and turn them into three.js animation clips

// tangential

// target

// target is a Vector3

// target position may be moved beyond boundary.

// tell browser that we plan to animate the placeholder

// tells the group to forget about a property path and no longer

// template is legacy prop

// test 3 face normals from the aabb

// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb

// test to see if both t0 and t1 are behind the ray - if so, return null

// test to see if t0 is behind the ray:

// tested with https://regex101.com/ on trick sequences

// texture

// texture stuff.

// textures

// that makes element fade out on close

// that's because I want to show image before it's fully loaded,

// that's why we delay it until the opener transition ends

// the GL state when required

// the actual area:

// the axis is seperating and we can exit

// the bindings again but can just copy

// the cumulative result and are compared to detect

// the current material requires lighting info

// the data then goes to 'incoming'

// the event is likely triggered by keyboard,

// the first pressed pointer

// the first uv buffer is just called 'uv'

// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

// the geometry and material are given to the latter.

// the interval is valid

// the location

// the loop above doesn't add the last group, do that here.

// the mesh represents this single instance

// the morphTarget is named.

// the next material that does gets activated:

// the point lies in with the minimum amount of redundant computation.

// the returned propertyListLen is not used

// the second pressed pointer

// the subdivision creates the vertex buffer data

// the value of this property will be used to advance the simulation.

// the values so that the near plane's position does not change in world space,

// the weight and shouldn't have made the call in the first place

// their entire buffer contents on the next tick.

// then it will not be updated.

// then sees LSB.

// then sort them

// there's no global clipping

// there's no local clipping

// these are used to "bind" a nonexistent property

// they are not painted during the transition

// they simply reference the renderer's state for their

// this action has been forgotten by the cache, but the user

// this code is required here because it is used by the toneMapping() function defined below

// this code is required here because it is used by the various encoding/decoding function defined below

// this condition block will be removed in the near future.

// this could be common when just three slides are used

// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

// this loop

// this means it should figure out its duration by scanning the tracks

// this method does not support reflection matrices

// this shows up in nearly every FBX file, and generally time array is length > 100

// this singularity is identity matrix so angle = 0

// this will be copied to parent, see above

// this.bufferAttribute.dynamic = false;

// this.bufferAttribute.dynamic = this.dynamicBuffer;

// this.bufferAttribute.usage = this.dynamicBuffer ?

// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped

// threejs.org/license

// threshold

// throws a "maximum call stack size exceeded" error for large arrays.

// thus it was created by Lightbox, based on

// times or values may be shared with other tracks, so overwriting is unsafe

// times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]

// to allow browser to show native dialog on longpress

// to calculate position and scale

// to check if rotation is not zero

// to find index of last vertex bit shift the index: ^ - 1

// to images in FBXTree.Objects.Video

// to keep receiving pointermove evens outside dragging iframe

// to make it we "clone" base icon shape and add border to it.

// to prevent pow( 0.0, 0.0 )

// to store intermediate quaternion multiplication results

// to support IE11 use some instead of Array#find (will be removed when IE11 is deprecated)

// to various AnimationCurveNodes and is referenced by an AnimationStack node

// todo

// toggling of inside/outside at every single! intersection point of an edge

// tone mapping

// top

// top vs. bottom // WebGL port note: Changed signs

// touch event does not have movementX and movementY.

// transform of empty box is an empty box.

// transform to world space

// transition through zero counts as a repetition,

// translate geometry

// translate object by distance along axis in object space

// translate triangle to aabb origin

// triangle bbox; min & max are calculated like this for speed

// triangle number in indexed buffer semantics

// triangle number in non-indexed buffer semantics

// tricky

// true -> zero effective time scale

// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)

// try filtering points and slicing again

// try splitting polygon into two and triangulate them independently

// try to get cached content

// tween's to on each update. That way the behavior is opt-in (there's

// twist a little...

// u = va * denom

// uint

// under the accompanying license; see chapter 5.1.5 for detailed explanation.

// unhide the placeholder

// unknown color

// unknown object -> add it to the ACTIVE region

// unlock color and depth buffer for subsequent rendering

// unoptimized: ! isNaN( firstElem )

// unschedule

// until we can determine that the gesture is swipe and its direction

// up and z are parallel

// up/down arrow keys pan the image vertically

// update camera and its children

// update camera matrices and frustum

// update children

// update current progress

// update existing pointer

// update points at the start of gesture

// update points that PhotoSwipe uses

// update points that were used during previous rAF tick

// update projection matrix for proper view frustum culling

// update resolution after gesture

// update resolution after transition ends

// update scene graph

// update the array previously obtained with 'subscribe_'

// update total number of vertices

// update, then the new tween will be updated in the next batch.

// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.

// upload an empty depth texture with framebuffer size

// upper triangle, YX order: (0,0)->(0,1)->(1,1)

// use  image-based placeholder only for the first slide,

// use already existing triangle edge vectors here

// use manually created mipmaps if available

// use the current material's .needsUpdate flags to set

// use the other end of the curve

// use these default values in WebGL. This avoids errors when buffer data is missing.

// used for storing cloned, shared data

// used for zoom gesture and ctrl/trackpad zoom

// used later to bind the skeleton to the model

// used to normalize

// user data

// user-controllable.

// user-defined clipping

// uses the array previously returned by 'getKeyframeOrder' to sort data

// using 4 splitting planes to rule out intersections

// using 6 splitting planes to rule out intersections.

// using decode() helps.

// using one of them

// using timeout as a safety fallback

// uv

// uv data of a single face

// uv repeat and offset setting priorities

// uvs

// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

// v.x = Math.abs( v.x );

// v.y = Math.abs( v.y );

// v.z = Math.abs( v.z );

// v8 likes predictible objects

// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

// validate_interval

// validation checks for WebGL 1

// value has changed -> update scene graph

// values

// var x = this.randomFloat( base.x, spread.x ),

// variables for result

// vec3( alive, age, maxAge, wiggle )

// vector from inPt to intersection point

// vector interpreted as a direction

// verify extension for WebGL 1 and WebGL 2

// verify extension for WebGL 1 only

// vertex

// vertex coordinates

// vertex index in coordinates array

// vertex region of A; barycentric coords (1, 0, 0)

// vertex region of B; barycentric coords (0, 1, 0)

// vertex region of C; barycentric coords (0, 0, 1)

// vertical angle

// vertical pass

// vertices has all points but contour has only points of circumference

// vertices, normals, uvs

// via FBXTree.Connections.

// viewZ is <= 0, so this is a difference equation

// w component is drag

// warning: null texture is valid

// warp done - apply final time scale

// we assume non-indexed geometry

// we could get finer grain at lengths, or use simple interpolation between two points

// we expect.So we create an intermediate buffer that points to the index in the buffer,

// we have arrived at the sought interval

// we ignore mass (assume that it's 1kg)

// we know the clip, so we don't have to parse all

// we might want to call this function with some ClippingGroup

// we need to store initial point to determine the main axis,

// we run two animations instead of one,

// we should not set that property in the object

// we use this multidimensional array as a data structure for creating the subdivision

// we wait till the current slide image placeholder is decoded,

// webpackBootstrap

// what frame of the texture the particle is using at it's current position in time.

// when it has 100% of viewport vertical space (height)

// when looping in reverse direction, the initial

// when the position doesn't have to be clamped

// when the position is completely stuck

// when using WebGLCubeRenderTarget.texture as a cube texture.

// when when somebody has screwed with setTimeout but no I.E. maddness

// where there are multiple layers per stack, we'll display a warning

// whether sector in vertex m contains sector in vertex p in the same coordinates

// which causes lag during the animation,

// which may be caused by resize or third party component,

// which might cause issues as browsers have a maximum transform limit.

// which seems to give a reasonable approximation

// while three.js uses a penumbra between (0, 1) to attenuate the inner angle

// width of the film (default in millimeters)

// will be replaced with `version` in package.json during the build process.

// wire up the material to this renderer's lighting state

// with OuterAngle > InnerAngle && OuterAngle <= Math.PI

// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );

// wrap around

// wrapped in strict mode code which doesn't define any globals.  It's inside a

// x - Negative x direction

// x, y, z, s, tex, numEmitters, maxParticles, parent)=>{

// x0<y0

// xr

// y - Negative y direction

// y = this.randomFloat( base.y, spread.y ),

// yet to come / don't decide when delta = 0

// z - Negative z direction

// z = this.randomFloat( base.z, spread.z );

// z key

// z-order curve value

// z-order of a point given coords and inverse of the longer side of data bbox

// z-order range for the current triangle bbox;

// zero angle, arbitrary axis

// zoom

// zoom.vFill defines zoom level of the image

// zoomSVG

// {

// { sums: cache, sum: sum }; Sum is in the last element.

// }

// ¯\_(ツ)_/¯

// π * 0.282095

//# sourceMappingURL=detect-gpu.esm.js.map

//( 0, t, t0 ), returns this.resultBuffer

//( N-1, tN-1, t ), returns this.resultBuffer

//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

//, true

//-

//-					if ( t < t0 || t0 === undefined ) {

//- 				if ( t >= t1 || t1 === undefined ) {

//- See http://jsperf.com/comparison-to-undefined/3

//- slower code:

/////  Internal functions

//////////////////////// GPU CHECK //////////////////////// 

//0.7,

//Move back to world space for distance calculation

//TODO: make this more efficient

//console.log("shape", shapes);

//console.log('b', i,j, i-1, k,vertices.length);

//const newHeight = this.scrollWrap.clientHeight;

//const newWidth = this.scrollWrap.clientWidth;

//context.stencilFunc( context.EQUAL, 1, 0xffffffff );

//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );

//for ( b = 1; b <= bevelSegments; b ++ ) {

//for ( b = bevelSegments; b > 0; b -- ) {

//normal enviroments in sane situations

//return point closest to the ray (positive side)

//this._prevViewportSize.x = newWidth;

//this._prevViewportSize.y = newHeight;

//this._startTime = this._intervalTime;

//this.zoomLevels.correctZoomPan();

//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

//uniforms.envMap.value = material.envMap; // part of uniforms common
